import{r as i,o as r,c as o,a as l,b as c,t as u,n as b,d,e as p,f as a}from"./index-k16LsOm-.js";const _={key:0,type:"I"},h=p('<li>原始類型 <ul><li>undefined，變數已被宣告，但尚未賦值，或者表示變數訪問的屬性或索引不存在。預設是undefined，完全<span class="r">虛無</span>的意思</li><li>null，表示空的、無效、未定義的值。表示具體的空值，可以賦值給對象。<span>有架子、沒紙捲筒</span></li><li>Boolean</li><li>String</li><li>Number</li><li>symbol <ul><li>ES6導入</li><li> const bunny = symbol(&quot;可愛的小兔子&quot;); <br> console.log(bunny.description); // 可愛的小兔子 </li><li>不能直接用遍歷、for迴圈撈取，要使用<span class="r">Object.getOwnPropertySymbols()</span></li><li>放在物件裡面，當作定義屬性key時，要將symbol的值放在[]當中，不然會被當字串</li><li>不能用 . 取得屬性值，要用[]</li><li>範例， <br><code> const classMate = { <br>  [Symbol(&#39;宜蓁&#39;)] : { score: 70, sleep: &#39;3:00&#39;, drink: true }, <br>  [Symbol(&#39;chita&#39;)] : { score: 90, sleep: &#39;20:00&#39;, drink:false }, <br>  [Symbol(&#39;宜蓁&#39;)] : { score: 100, sleep: &#39;19:00&#39;, drink: false }, <br> } <br> const symbols = Object.getOwnPropertySymbols(classMate); <br> for (const symbol of symbols) { <br>  if (symbol.toString() === &#39;Symbol(宜蓁)&#39;) { <br>   const value = classMate[symbol]; <br>   console.log(value); // { score: 100, sleep: &#39;19:00&#39;, drink: false } <br>  } <br> } <br></code></li></ul></li></ul></li><li>物件類型 <ul><li>Object</li><li>Array</li><li>Function</li><li>Date</li><li>Regexp <ul> 範例，身分證字號 <br><code> function isValidTaiwanId(id) { <br>  const taiwanIdRegex = /^[A-Z][12]\\d{8}$/; <br>  return taiwanIdRegex.test(id); <br> } </code><br> ^，表示匹配輸入的開始位置。 <br> [A-Z]，表示批妹一個大寫字母。 <br> [12]，表示匹配字符1或2 <br> \\d{8}，表示匹配後面8個數字 <br> $，表示匹配輸入的結束位置 </ul></li></ul></li>',2),g=[h],v={__name:"ch1",props:{title:String},setup(s){const e=i(!1);return(n,t)=>(r(),o("div",null,[l("h2",{onClick:t[0]||(t[0]=m=>e.value=!e.value)},[c(u(s.title)+" ",1),l("div",{class:b(["isShow",e.value?"":"rotate180"])},"^",2)]),e.value?(r(),o("ol",_,g)):d("",!0)]))}},y={key:0,type:"I"},f=p('<li> JS中實現繼承和屬性查找的一種機制，在JS中，每個對象都有一個指向其原型的鏈接。 </li><li> 當我們訪問的一個對象的屬性或方法，如果對象沒有屬性或方法，JS引擎會沿著原型練往上查找，直到找到相應屬性或原型練的頂端<span class="r">Object.prototype</span>。 </li><li> 範例，<br><code> function Animal(name) { <br>   this.name = name; <br>  } <br> Animal.prototype.sayHello = function(){ <br>  console.log(`Hello, I&#39;m ${this.name}`); <br> } <br> let dog = new Animal(&quot;Dog&quot;); <br> dog.sayHello(); </code></li>',3),S=[f],w={__name:"ch3",props:{title:String},setup(s){const e=i(!1);return(n,t)=>(r(),o("div",null,[l("h2",{onClick:t[0]||(t[0]=m=>e.value=!e.value)},[c(u(s.title)+" ",1),l("div",{class:b(["isShow",e.value?"":"rotate180"])},"^",2)]),e.value?(r(),o("ol",y,S)):d("",!0)]))}},$={key:0,type:"I"},k=p('<li>沒有自己的this，不會創建自己的this，而是繼承父作用域(外部作用域)的this <br><code> const obj = { <br>  name: &#39;John&#39;, <br>  greet: function() { <br>   setTimeout(function() { <br>    console.log(&#39;Hello, &#39; + this.name); // 此处的 this 指向了全局对象(在浏览器中是 window)，输出 undefined <br>   }, 1000); <br>  }, <br>  greet2:function(){ <br>   setTimeout(() =&gt; { <br>     console.log(&#39;Hello, &#39; + this.name); // 此处的 this 繼承了父作用域，指向了自身，輸出為John <br>   }, timeout); <br>  } <br> }; <br> obj.greet(); // 调用 greet 方法 obj.greet2(); // 调用 greet2 方法 </code></li><li>無法作為建構式，箭頭函數不能用new來創建物件實例，因此不能用做構造函數 <ul><li>傳統函數，有自己的this <br><code> function Person(name, age) { <br>  this.name = name; // 設置name屬性 <br>  this.age = age; // 設置age屬性 <br> } <br> // 使用構造函數創建實例 <br> const john = new Person(&#39;John&#39;, 30); <br> console.log(john.name); // john </code></li></ul></li><li>不能使用arguments，箭頭函數內部沒有自己的arguments對象，而是繼承了父層的arguments對象 <ul><li>arguments是一個特殊的對象，它包含了函數被調用時傳遞給函數的參數列表，類似數組、但不是數組，主要用於訪問函數參數，而非操作</li><li><code> aa(1,2,3); // [1,2,3]就是arguments </code></li><li> 但若想在箭頭函數中訪問參數，用剩餘參數與法撈取 <ul><li><span class="r">剩餘參數</span>，捕獲多餘的參數</li><li><code> const arrowFunctionWithArgs = (...args) =&gt; { <br>  console.log(args); <br> } <br> arrowFunctionWithArgs(1, 2, 3); // 输出: [1, 2, 3] </code></li><li><code> function sum(...args) { <br>  let total = 0; <br>  for (let arg of args) { <br>   total += arg; <br>  } <br>  return total; <br> } <br> console.log(sum(1, 2, 3)); // 输出: 6 </code></li></ul></li></ul></li><li> 不能用於定義原型方法，由於箭頭函數沒有自己的this，所以無法定義原型方法 </li>',4),A=[k],j={__name:"ch4",props:{title:String},setup(s){const e=i(!1);return(n,t)=>(r(),o("div",null,[l("h2",{onClick:t[0]||(t[0]=m=>e.value=!e.value)},[c(u(s.title)+" ",1),l("div",{class:b(["isShow",e.value?"":"rotate180"])},"^",2)]),e.value?(r(),o("ol",$,A)):d("",!0)]))}},x={key:0,type:"I"},I=p("<li> 陣列，用[]解構 <ul><li><code> let [a, b] = [1, 2]; <br> console.log(a); // 输出: 1 </code></li></ul></li><li>物件，用{}解構 <ul><li><code> let { city, country } = { city: &#39;New York&#39;, country: &#39;USA&#39; }; <br> console.log(city); // 输出: New York </code></li><li>重新賦值 <code> let { a: x, b: y } = { a: 10, b: 20 }; <br> console.log(x); // 输出: 10 </code></li><li>默認值 <code> let { firstName = &#39;John&#39;, lastName = &#39;Doe&#39; } = {}; <br> console.log(firstName); // 输出: John </code></li></ul></li><li>函式可套用前兩者</li>",3),N=[I],P={__name:"ch5",props:{title:String},setup(s){const e=i(!1);return(n,t)=>(r(),o("div",null,[l("h2",{onClick:t[0]||(t[0]=m=>e.value=!e.value)},[c(u(s.title)+" ",1),l("div",{class:b(["isShow",e.value?"":"rotate180"])},"^",2)]),e.value?(r(),o("ol",x,N)):d("",!0)]))}},C={key:0,type:"I"},D=p('<li> Promise是一種用於處理非同步操作的功能(依序處理非同步)，他代表一個非同步操作的最終完成或失敗，並取得其結果。 </li><li>Pedning 等待中 / Resolved 成功 / Rejected 失敗</li><li>promise內部執行是同步的，當創建promise時，其執行器函數會<span class="r">立即執行</span>並且在執行器函數內部的代碼都是同步執行，直到遇到非同步操作或是返回一個promise對象為止 </li><li>常見的非同步操作有，settimeout、事件監聽、網路請求</li><li>標準使用方法如下 <br><code> // 創建一個promise <br> const mypromise = <span class="r">new Promise((resolve, reject)</span> =&gt; { <br>  // 開始非同步操作 <br>  setTimeout(() =&gt; { <br>    const randomNumber = Math.random(); <br>    if (randomNumber &gt; 0.5) { <br>    // 操作成功 <br>      resolve(randomNumber); <br>    } else { <br>     // 操作失敗 <br>     reject(new Error(&quot;andom number is less than 0.5&quot;)); <br>     } <br>  }, 1000); <br> }); <br> <br> // 使用非同步 <br> mypromise.<span class="r">then</span>((result) =&gt; { <br>  console.log(&#39;Promise resolved with result:&#39;, result); <br> }).<span class="r">catch</span>((err) =&gt; { <br>  console.error(&#39;Promise rejected with error:&#39;, err); <br> }) </code></li>',5),E=[D],O={__name:"ch6",props:{title:String},setup(s){const e=i(!1);return(n,t)=>(r(),o("div",null,[l("h2",{onClick:t[0]||(t[0]=m=>e.value=!e.value)},[c(u(s.title)+" ",1),l("div",{class:b(["isShow",e.value?"":"rotate180"])},"^",2)]),e.value?(r(),o("ol",C,E)):d("",!0)]))}},J={key:0,type:"I"},q=p("<li>Array <ul><li>添加新的元素至Array，Arr.push(123)</li><li>splice()，用於Arr的插入、刪除、替換元素、修改、返回已刪除的元素</li><li>Arr.splice(要操作的起始索引,要刪除的元素數量,要插入的元素) <br> Array.splice(1,2,&quot;orange&quot;) 從索引1開始，刪除兩個元素，並插入1個ornage元素 </li><li>Arr的轉換 <br> const numbers = [1, 2, 3, 4, 5]; <ul><li> map，將數組的每個元素應用於指定函數，並返回一個新的數組，新數組包含了每個元素調用該函數後的結果。 <br> doubled = numbers.map(num =&gt; num * 2); // [2, 4, 6, 8, 10] </li><li> filter，方法用於從數組中過濾出滿足指定條件的元素，並返回一個新的數組，新數組包含了滿足條件的所有元素。 <br> doubled = numbers.filter(num =&gt; num % 2 === 0); // [2, 4] </li><li> reduce，方法用於將數組的所有元素歸納（累加）為一個單一的值，通常是一個數字、字符串或對象。 <br> doubled = numbers.reduce((acc, num) =&gt; acc + num, 0); // 15 </li></ul></li></ul></li><li>Object <ul><li>刪除，delete Object.gender // 刪除Object.gender屬性</li></ul></li>",2),T=[q],R={__name:"ch7",props:{title:String},setup(s){const e=i(!1);return i(!1),(n,t)=>(r(),o("div",null,[l("h2",{onClick:t[0]||(t[0]=m=>e.value=!e.value)},[c(u(s.title)+" ",1),l("div",{class:b(["isShow",e.value?"":"rotate180"])},"^",2)]),e.value?(r(),o("ol",J,T)):d("",!0)]))}},V={key:0,type:"I"},B=l("li",null,"return，結束當前函式",-1),F=l("li",null,"break，跳出循環",-1),H=l("li",null,"continue，跳到下一次的迴圈",-1),M=[B,F,H],W={__name:"ch8",props:{title:String},setup(s){const e=i(!1);return i(!1),(n,t)=>(r(),o("div",null,[l("h2",{onClick:t[0]||(t[0]=m=>e.value=!e.value)},[c(u(s.title)+" ",1),l("div",{class:b(["isShow",e.value?"":"rotate180"])},"^",2)]),e.value?(r(),o("ol",V,M)):d("",!0)]))}},Y={key:0,type:"I"},Z=p('<li> async/await，算是promise的語法糖，需要有promise回傳，才能執行下一步 </li><li>settimeout不會回傳promise，要另外創建 <br><code> // 定義一個非同步函數 <br> const fetchData = async () =&gt; { <br>  return new Promise((resolve, reject) =&gt; { <br>    // 模拟非同步操作 <br>    setTimeout(() =&gt; { <br>      resolve(&#39;Async data&#39;); <br>    }, 1000); <br>  }); <br> }; <br> // 調用非同步函數 <br> const getData = <span class="r">async</span> () =&gt; { <br>  try { <br>    const data = <span class="r">await</span> fetchData(); <br>    console.log(&#39;Data:&#39;, data); // Data: Async data <br>   } catch (error) { <br>    console.error(&#39;Error:&#39;, error); <br>  } <br> }; <br> getData(); </code></li><li>API請求會有promsie</li><li>文件讀取也有promise <br><code> const fileInput = document.getElementById(&#39;file-input&#39;); <br> fileInput.addEventListener(&#39;change&#39;, () =&gt; { <br>  const file = fileInput.files[0]; <br>  const reader = new FileReader(); <br>  reader.readAsText(file); <br>  reader.onload = () =&gt; { <br>   console.log(&#39;File content:&#39;, reader.result); <br>  }; <br> }); </code></li>',4),z=[Z],L={__name:"ch9",props:{title:String},setup(s){const e=i(!1);return(n,t)=>(r(),o("div",null,[l("h2",{onClick:t[0]||(t[0]=m=>e.value=!e.value)},[c(u(s.title)+" ",1),l("div",{class:b(["isShow",e.value?"":"rotate180"])},"^",2)]),e.value?(r(),o("ol",Y,z)):d("",!0)]))}},G={__name:"JS_basic",setup(s){return(e,n)=>(r(),o("div",null,[a(v,{title:"數據類型"}),a(w,{title:"原型链(原型方法)"}),a(j,{title:"箭頭函數(ES6)"}),a(P,{title:"解構賦值(ES6)"}),a(R,{title:"Array/Object"}),a(W,{title:"break/continue/return"}),a(O,{title:"非同步(ES6)-promise"}),a(L,{title:"非同步(ES6)-async"})]))}};export{G as default};
