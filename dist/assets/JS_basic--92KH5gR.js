import{r as a,o as s,c as i,a as o,b as c,t as u,n as b,d,e as _,p as h,f as g,g as r}from"./index-Desngf0b.js";import{_ as f}from"./_plugin-vue_export-helper-x3n3nnut.js";const v={key:0,type:"I"},y=_('<li>原始類型 <ul><li>undefined，變數已被宣告，但尚未賦值，或者表示變數訪問的屬性或索引不存在。預設是undefined，完全<span class="r">虛無</span>的意思</li><li>null，表示空的、無效、未定義的值。表示具體的空值，可以賦值給對象。<span>有架子、沒紙捲筒</span></li><li>Boolean</li><li>String</li><li>Number</li><li>symbol <ul><li>ES6導入</li><li> const bunny = symbol(&quot;可愛的小兔子&quot;); <br> console.log(bunny.description); // 可愛的小兔子 </li><li>不能直接用遍歷、for迴圈撈取，要使用<span class="r">Object.getOwnPropertySymbols()</span></li><li>放在物件裡面，當作定義屬性key時，要將symbol的值放在[]當中，不然會被當字串</li><li>不能用 . 取得屬性值，要用[]</li><li>範例， <br><code> const classMate = { <br>  [Symbol(&#39;宜蓁&#39;)] : { score: 70, sleep: &#39;3:00&#39;, drink: true }, <br>  [Symbol(&#39;chita&#39;)] : { score: 90, sleep: &#39;20:00&#39;, drink:false }, <br>  [Symbol(&#39;宜蓁&#39;)] : { score: 100, sleep: &#39;19:00&#39;, drink: false }, <br> } <br> const symbols = Object.getOwnPropertySymbols(classMate); <br> for (const symbol of symbols) { <br>  if (symbol.toString() === &#39;Symbol(宜蓁)&#39;) { <br>   const value = classMate[symbol]; <br>   console.log(value); // { score: 100, sleep: &#39;19:00&#39;, drink: false } <br>  } <br> } <br></code></li></ul></li></ul></li><li>物件類型 <ul><li>Object</li><li>Array</li><li>Function</li><li>Date</li><li>Regexp <ul> 範例，身分證字號 <br><code> function isValidTaiwanId(id) { <br>  const taiwanIdRegex = /^[A-Z][12]\\d{8}$/; <br>  return taiwanIdRegex.test(id); <br> } </code><br> ^，表示匹配輸入的開始位置。 <br> [A-Z]，表示批妹一個大寫字母。 <br> [12]，表示匹配字符1或2 <br> \\d{8}，表示匹配後面8個數字 <br> $，表示匹配輸入的結束位置 </ul></li></ul></li>',2),S=[y],w={__name:"ch1",props:{title:String},setup(t){const e=a(!1);return(n,l)=>(s(),i("div",null,[o("h2",{onClick:l[0]||(l[0]=m=>e.value=!e.value)},[c(u(t.title)+" ",1),o("div",{class:b(["isShow",e.value?"":"rotate180"])},"^",2)]),e.value?(s(),i("ol",v,S)):d("",!0)]))}},p=t=>(h("data-v-fc853031"),t=t(),g(),t),$={key:0,type:"I"},k=p(()=>o("li",null,"var，宣告的變數存在變數提升(code執行過程，會被提升至作用域的頂部)，作用範圍為全域",-1)),I=p(()=>o("li",null,"let，存在變數提升，但是在初始化之前訪問，會出現暫時性死區。宣告的變數可重新賦值",-1)),x=p(()=>o("li",null,"const，存在變數提升，宣告的變數為常數",-1)),j=[k,I,x],A={__name:"ch2",props:{title:String},setup(t){const e=a(!1);return(n,l)=>(s(),i("div",null,[o("h2",{onClick:l[0]||(l[0]=m=>e.value=!e.value)},[c(u(t.title)+" ",1),o("div",{class:b(["isShow",e.value?"":"rotate180"])},"^",2)]),e.value?(s(),i("ol",$,j)):d("",!0)]))}},J=f(A,[["__scopeId","data-v-fc853031"]]),C={key:0,type:"I"},N=_('<li> JS中實現繼承和屬性查找的一種機制，在JS中，每個對象都有一個指向其原型的鏈接。 </li><li> 當我們訪問的一個對象的屬性或方法，如果對象沒有屬性或方法，JS引擎會沿著原型練往上查找，直到找到相應屬性或原型練的頂端<span class="r">Object.prototype</span>。 </li><li> 範例，<br><code> function Animal(name) { <br>   this.name = name; <br>  } <br> Animal.prototype.sayHello = function(){ <br>  console.log(`Hello, I&#39;m ${this.name}`); <br> } <br> let dog = new Animal(&quot;Dog&quot;); <br> dog.sayHello(); </code></li>',3),O=[N],V={__name:"ch3",props:{title:String},setup(t){const e=a(!1);return(n,l)=>(s(),i("div",null,[o("h2",{onClick:l[0]||(l[0]=m=>e.value=!e.value)},[c(u(t.title)+" ",1),o("div",{class:b(["isShow",e.value?"":"rotate180"])},"^",2)]),e.value?(s(),i("ol",C,O)):d("",!0)]))}},H={key:0,type:"I"},q=_('<li>沒有自己的this，不會創建自己的this，而是繼承父作用域(外部作用域)的this <br><code> const obj = { <br>  name: &#39;John&#39;, <br>  greet: function() { <br>   setTimeout(function() { <br>    console.log(&#39;Hello, &#39; + this.name); // 此处的 this 指向了全局对象(在浏览器中是 window)，输出 undefined <br>   }, 1000); <br>  }, <br>  greet2:function(){ <br>   setTimeout(() =&gt; { <br>     console.log(&#39;Hello, &#39; + this.name); // 此处的 this 繼承了父作用域，指向了自身，輸出為John <br>   }, timeout); <br>  } <br> }; <br> obj.greet(); // 调用 greet 方法 obj.greet2(); // 调用 greet2 方法 </code></li><li>無法作為建構式，箭頭函數不能用new來創建物件實例，因此不能用做構造函數 <ul><li>傳統函數，有自己的this <br><code> function Person(name, age) { <br>  this.name = name; // 設置name屬性 <br>  this.age = age; // 設置age屬性 <br> } <br> // 使用構造函數創建實例 <br> const john = new Person(&#39;John&#39;, 30); <br> console.log(john.name); // john </code></li></ul></li><li>不能使用arguments，箭頭函數內部沒有自己的arguments對象，而是繼承了父層的arguments對象 <ul><li>arguments是一個特殊的對象，它包含了函數被調用時傳遞給函數的參數列表，類似數組、但不是數組，主要用於訪問函數參數，而非操作</li><li><code> aa(1,2,3); // [1,2,3]就是arguments </code></li><li> 但若想在箭頭函數中訪問參數，用剩餘參數與法撈取 <ul><li><span class="r">剩餘參數</span>，捕獲多餘的參數</li><li><code> const arrowFunctionWithArgs = (...args) =&gt; { <br>  console.log(args); <br> } <br> arrowFunctionWithArgs(1, 2, 3); // 输出: [1, 2, 3] </code></li><li><code> function sum(...args) { <br>  let total = 0; <br>  for (let arg of args) { <br>   total += arg; <br>  } <br>  return total; <br> } <br> console.log(sum(1, 2, 3)); // 输出: 6 </code></li></ul></li></ul></li><li> 不能用於定義原型方法，由於箭頭函數沒有自己的this，所以無法定義原型方法 </li>',4),B=[q],P={__name:"ch4",props:{title:String},setup(t){const e=a(!1);return(n,l)=>(s(),i("div",null,[o("h2",{onClick:l[0]||(l[0]=m=>e.value=!e.value)},[c(u(t.title)+" ",1),o("div",{class:b(["isShow",e.value?"":"rotate180"])},"^",2)]),e.value?(s(),i("ol",H,B)):d("",!0)]))}},E={__name:"JS_basic",setup(t){return(e,n)=>(s(),i("div",null,[r(w,{title:"數據類型"}),r(J,{title:"變量"}),r(V,{title:"原型链(原型方法)"}),r(P,{title:"箭頭函數(ES6)"})]))}};export{E as default};
