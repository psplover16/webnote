{
  "version": 3,
  "sources": ["../../@vue/devtools-api/lib/esm/env.js", "../../@vue/devtools-api/lib/esm/const.js", "../../@vue/devtools-api/lib/esm/time.js", "../../@vue/devtools-api/lib/esm/proxy.js", "../../@vue/devtools-api/lib/esm/index.js", "../../vue-router/dist/vue-router.esm-bundler.js"],
  "sourcesContent": ["export function getDevtoolsGlobalHook() {\n  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;\n}\nexport function getTarget() {\n  // @ts-ignore\n  return typeof navigator !== 'undefined' && typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : {};\n}\nexport const isProxyAvailable = typeof Proxy === 'function';", "export const HOOK_SETUP = 'devtools-plugin:setup';\nexport const HOOK_PLUGIN_SETTINGS_SET = 'plugin:settings:set';", "let supported;\nlet perf;\nexport function isPerformanceSupported() {\n  var _a;\n  if (supported !== undefined) {\n    return supported;\n  }\n  if (typeof window !== 'undefined' && window.performance) {\n    supported = true;\n    perf = window.performance;\n  } else if (typeof global !== 'undefined' && ((_a = global.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {\n    supported = true;\n    perf = global.perf_hooks.performance;\n  } else {\n    supported = false;\n  }\n  return supported;\n}\nexport function now() {\n  return isPerformanceSupported() ? perf.now() : Date.now();\n}", "import { HOOK_PLUGIN_SETTINGS_SET } from './const.js';\nimport { now } from './time.js';\nexport class ApiProxy {\n  constructor(plugin, hook) {\n    this.target = null;\n    this.targetQueue = [];\n    this.onQueue = [];\n    this.plugin = plugin;\n    this.hook = hook;\n    const defaultSettings = {};\n    if (plugin.settings) {\n      for (const id in plugin.settings) {\n        const item = plugin.settings[id];\n        defaultSettings[id] = item.defaultValue;\n      }\n    }\n    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;\n    let currentSettings = Object.assign({}, defaultSettings);\n    try {\n      const raw = localStorage.getItem(localSettingsSaveId);\n      const data = JSON.parse(raw);\n      Object.assign(currentSettings, data);\n    } catch (e) {\n      // noop\n    }\n    this.fallbacks = {\n      getSettings() {\n        return currentSettings;\n      },\n      setSettings(value) {\n        try {\n          localStorage.setItem(localSettingsSaveId, JSON.stringify(value));\n        } catch (e) {\n          // noop\n        }\n        currentSettings = value;\n      },\n      now() {\n        return now();\n      }\n    };\n    if (hook) {\n      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {\n        if (pluginId === this.plugin.id) {\n          this.fallbacks.setSettings(value);\n        }\n      });\n    }\n    this.proxiedOn = new Proxy({}, {\n      get: (_target, prop) => {\n        if (this.target) {\n          return this.target.on[prop];\n        } else {\n          return (...args) => {\n            this.onQueue.push({\n              method: prop,\n              args\n            });\n          };\n        }\n      }\n    });\n    this.proxiedTarget = new Proxy({}, {\n      get: (_target, prop) => {\n        if (this.target) {\n          return this.target[prop];\n        } else if (prop === 'on') {\n          return this.proxiedOn;\n        } else if (Object.keys(this.fallbacks).includes(prop)) {\n          return (...args) => {\n            this.targetQueue.push({\n              method: prop,\n              args,\n              resolve: () => {}\n            });\n            return this.fallbacks[prop](...args);\n          };\n        } else {\n          return (...args) => {\n            return new Promise(resolve => {\n              this.targetQueue.push({\n                method: prop,\n                args,\n                resolve\n              });\n            });\n          };\n        }\n      }\n    });\n  }\n  async setRealTarget(target) {\n    this.target = target;\n    for (const item of this.onQueue) {\n      this.target.on[item.method](...item.args);\n    }\n    for (const item of this.targetQueue) {\n      item.resolve(await this.target[item.method](...item.args));\n    }\n  }\n}", "import { getTarget, getDevtoolsGlobalHook, isProxyAvailable } from './env.js';\nimport { HOOK_SETUP } from './const.js';\nimport { ApiProxy } from './proxy.js';\nexport * from './api/index.js';\nexport * from './plugin.js';\nexport * from './time.js';\nexport function setupDevtoolsPlugin(pluginDescriptor, setupFn) {\n  const descriptor = pluginDescriptor;\n  const target = getTarget();\n  const hook = getDevtoolsGlobalHook();\n  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;\n  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {\n    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);\n  } else {\n    const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;\n    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];\n    list.push({\n      pluginDescriptor: descriptor,\n      setupFn,\n      proxy\n    });\n    if (proxy) setupFn(proxy.proxiedTarget);\n  }\n}", "/*!\r\n  * vue-router v4.0.13\r\n  * (c) 2022 Eduardo San Martin Morote\r\n  * @license MIT\r\n  */\nimport { getCurrentInstance, inject, onUnmounted, onDeactivated, onActivated, computed, unref, watchEffect, defineComponent, reactive, h, provide, ref, watch, shallowRef, nextTick } from 'vue';\nimport { setupDevtoolsPlugin } from '@vue/devtools-api';\nconst hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\nconst PolySymbol = name =>\n// vr = vue router\nhasSymbol ? Symbol(process.env.NODE_ENV !== 'production' ? '[vue-router]: ' + name : name) : (process.env.NODE_ENV !== 'production' ? '[vue-router]: ' : '_vr_') + name;\n// rvlm = Router View Location Matched\n/**\r\n * RouteRecord being rendered by the closest ancestor Router View. Used for\r\n * `onBeforeRouteUpdate` and `onBeforeRouteLeave`. rvlm stands for Router View\r\n * Location Matched\r\n *\r\n * @internal\r\n */\nconst matchedRouteKey = /*#__PURE__*/PolySymbol(process.env.NODE_ENV !== 'production' ? 'router view location matched' : 'rvlm');\n/**\r\n * Allows overriding the router view depth to control which component in\r\n * `matched` is rendered. rvd stands for Router View Depth\r\n *\r\n * @internal\r\n */\nconst viewDepthKey = /*#__PURE__*/PolySymbol(process.env.NODE_ENV !== 'production' ? 'router view depth' : 'rvd');\n/**\r\n * Allows overriding the router instance returned by `useRouter` in tests. r\r\n * stands for router\r\n *\r\n * @internal\r\n */\nconst routerKey = /*#__PURE__*/PolySymbol(process.env.NODE_ENV !== 'production' ? 'router' : 'r');\n/**\r\n * Allows overriding the current route returned by `useRoute` in tests. rl\r\n * stands for route location\r\n *\r\n * @internal\r\n */\nconst routeLocationKey = /*#__PURE__*/PolySymbol(process.env.NODE_ENV !== 'production' ? 'route location' : 'rl');\n/**\r\n * Allows overriding the current route used by router-view. Internally this is\r\n * used when the `route` prop is passed.\r\n *\r\n * @internal\r\n */\nconst routerViewLocationKey = /*#__PURE__*/PolySymbol(process.env.NODE_ENV !== 'production' ? 'router view location' : 'rvl');\nconst isBrowser = typeof window !== 'undefined';\nfunction isESModule(obj) {\n  return obj.__esModule || hasSymbol && obj[Symbol.toStringTag] === 'Module';\n}\nconst assign = Object.assign;\nfunction applyToParams(fn, params) {\n  const newParams = {};\n  for (const key in params) {\n    const value = params[key];\n    newParams[key] = Array.isArray(value) ? value.map(fn) : fn(value);\n  }\n  return newParams;\n}\nconst noop = () => {};\nfunction warn(msg) {\n  // avoid using ...args as it breaks in older Edge builds\n  const args = Array.from(arguments).slice(1);\n  console.warn.apply(console, ['[Vue Router warn]: ' + msg].concat(args));\n}\nconst TRAILING_SLASH_RE = /\\/$/;\nconst removeTrailingSlash = path => path.replace(TRAILING_SLASH_RE, '');\n/**\r\n * Transforms an URI into a normalized history location\r\n *\r\n * @param parseQuery\r\n * @param location - URI to normalize\r\n * @param currentLocation - current absolute location. Allows resolving relative\r\n * paths. Must start with `/`. Defaults to `/`\r\n * @returns a normalized history location\r\n */\nfunction parseURL(parseQuery, location, currentLocation = '/') {\n  let path,\n    query = {},\n    searchString = '',\n    hash = '';\n  // Could use URL and URLSearchParams but IE 11 doesn't support it\n  const searchPos = location.indexOf('?');\n  const hashPos = location.indexOf('#', searchPos > -1 ? searchPos : 0);\n  if (searchPos > -1) {\n    path = location.slice(0, searchPos);\n    searchString = location.slice(searchPos + 1, hashPos > -1 ? hashPos : location.length);\n    query = parseQuery(searchString);\n  }\n  if (hashPos > -1) {\n    path = path || location.slice(0, hashPos);\n    // keep the # character\n    hash = location.slice(hashPos, location.length);\n  }\n  // no search and no query\n  path = resolveRelativePath(path != null ? path : location, currentLocation);\n  // empty path means a relative query or hash `?foo=f`, `#thing`\n  return {\n    fullPath: path + (searchString && '?') + searchString + hash,\n    path,\n    query,\n    hash\n  };\n}\n/**\r\n * Stringifies a URL object\r\n *\r\n * @param stringifyQuery\r\n * @param location\r\n */\nfunction stringifyURL(stringifyQuery, location) {\n  const query = location.query ? stringifyQuery(location.query) : '';\n  return location.path + (query && '?') + query + (location.hash || '');\n}\n/**\r\n * Strips off the base from the beginning of a location.pathname in a non\r\n * case-sensitive way.\r\n *\r\n * @param pathname - location.pathname\r\n * @param base - base to strip off\r\n */\nfunction stripBase(pathname, base) {\n  // no base or base is not found at the beginning\n  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase())) return pathname;\n  return pathname.slice(base.length) || '/';\n}\n/**\r\n * Checks if two RouteLocation are equal. This means that both locations are\r\n * pointing towards the same {@link RouteRecord} and that all `params`, `query`\r\n * parameters and `hash` are the same\r\n *\r\n * @param a - first {@link RouteLocation}\r\n * @param b - second {@link RouteLocation}\r\n */\nfunction isSameRouteLocation(stringifyQuery, a, b) {\n  const aLastIndex = a.matched.length - 1;\n  const bLastIndex = b.matched.length - 1;\n  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery(a.query) === stringifyQuery(b.query) && a.hash === b.hash;\n}\n/**\r\n * Check if two `RouteRecords` are equal. Takes into account aliases: they are\r\n * considered equal to the `RouteRecord` they are aliasing.\r\n *\r\n * @param a - first {@link RouteRecord}\r\n * @param b - second {@link RouteRecord}\r\n */\nfunction isSameRouteRecord(a, b) {\n  // since the original record has an undefined value for aliasOf\n  // but all aliases point to the original record, this will always compare\n  // the original record\n  return (a.aliasOf || a) === (b.aliasOf || b);\n}\nfunction isSameRouteLocationParams(a, b) {\n  if (Object.keys(a).length !== Object.keys(b).length) return false;\n  for (const key in a) {\n    if (!isSameRouteLocationParamsValue(a[key], b[key])) return false;\n  }\n  return true;\n}\nfunction isSameRouteLocationParamsValue(a, b) {\n  return Array.isArray(a) ? isEquivalentArray(a, b) : Array.isArray(b) ? isEquivalentArray(b, a) : a === b;\n}\n/**\r\n * Check if two arrays are the same or if an array with one single entry is the\r\n * same as another primitive value. Used to check query and parameters\r\n *\r\n * @param a - array of values\r\n * @param b - array of values or a single value\r\n */\nfunction isEquivalentArray(a, b) {\n  return Array.isArray(b) ? a.length === b.length && a.every((value, i) => value === b[i]) : a.length === 1 && a[0] === b;\n}\n/**\r\n * Resolves a relative path that starts with `.`.\r\n *\r\n * @param to - path location we are resolving\r\n * @param from - currentLocation.path, should start with `/`\r\n */\nfunction resolveRelativePath(to, from) {\n  if (to.startsWith('/')) return to;\n  if (process.env.NODE_ENV !== 'production' && !from.startsWith('/')) {\n    warn(`Cannot resolve a relative location without an absolute path. Trying to resolve \"${to}\" from \"${from}\". It should look like \"/${from}\".`);\n    return to;\n  }\n  if (!to) return from;\n  const fromSegments = from.split('/');\n  const toSegments = to.split('/');\n  let position = fromSegments.length - 1;\n  let toPosition;\n  let segment;\n  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {\n    segment = toSegments[toPosition];\n    // can't go below zero\n    if (position === 1 || segment === '.') continue;\n    if (segment === '..') position--;\n    // found something that is not relative path\n    else break;\n  }\n  return fromSegments.slice(0, position).join('/') + '/' + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join('/');\n}\nvar NavigationType;\n(function (NavigationType) {\n  NavigationType[\"pop\"] = \"pop\";\n  NavigationType[\"push\"] = \"push\";\n})(NavigationType || (NavigationType = {}));\nvar NavigationDirection;\n(function (NavigationDirection) {\n  NavigationDirection[\"back\"] = \"back\";\n  NavigationDirection[\"forward\"] = \"forward\";\n  NavigationDirection[\"unknown\"] = \"\";\n})(NavigationDirection || (NavigationDirection = {}));\n/**\r\n * Starting location for Histories\r\n */\nconst START = '';\n// Generic utils\n/**\r\n * Normalizes a base by removing any trailing slash and reading the base tag if\r\n * present.\r\n *\r\n * @param base - base to normalize\r\n */\nfunction normalizeBase(base) {\n  if (!base) {\n    if (isBrowser) {\n      // respect <base> tag\n      const baseEl = document.querySelector('base');\n      base = baseEl && baseEl.getAttribute('href') || '/';\n      // strip full URL origin\n      base = base.replace(/^\\w+:\\/\\/[^\\/]+/, '');\n    } else {\n      base = '/';\n    }\n  }\n  // ensure leading slash when it was removed by the regex above avoid leading\n  // slash with hash because the file could be read from the disk like file://\n  // and the leading slash would cause problems\n  if (base[0] !== '/' && base[0] !== '#') base = '/' + base;\n  // remove the trailing slash so all other method can just do `base + fullPath`\n  // to build an href\n  return removeTrailingSlash(base);\n}\n// remove any character before the hash\nconst BEFORE_HASH_RE = /^[^#]+#/;\nfunction createHref(base, location) {\n  return base.replace(BEFORE_HASH_RE, '#') + location;\n}\nfunction getElementPosition(el, offset) {\n  const docRect = document.documentElement.getBoundingClientRect();\n  const elRect = el.getBoundingClientRect();\n  return {\n    behavior: offset.behavior,\n    left: elRect.left - docRect.left - (offset.left || 0),\n    top: elRect.top - docRect.top - (offset.top || 0)\n  };\n}\nconst computeScrollPosition = () => ({\n  left: window.pageXOffset,\n  top: window.pageYOffset\n});\nfunction scrollToPosition(position) {\n  let scrollToOptions;\n  if ('el' in position) {\n    const positionEl = position.el;\n    const isIdSelector = typeof positionEl === 'string' && positionEl.startsWith('#');\n    /**\r\n     * `id`s can accept pretty much any characters, including CSS combinators\r\n     * like `>` or `~`. It's still possible to retrieve elements using\r\n     * `document.getElementById('~')` but it needs to be escaped when using\r\n     * `document.querySelector('#\\\\~')` for it to be valid. The only\r\n     * requirements for `id`s are them to be unique on the page and to not be\r\n     * empty (`id=\"\"`). Because of that, when passing an id selector, it should\r\n     * be properly escaped for it to work with `querySelector`. We could check\r\n     * for the id selector to be simple (no CSS combinators `+ >~`) but that\r\n     * would make things inconsistent since they are valid characters for an\r\n     * `id` but would need to be escaped when using `querySelector`, breaking\r\n     * their usage and ending up in no selector returned. Selectors need to be\r\n     * escaped:\r\n     *\r\n     * - `#1-thing` becomes `#\\31 -thing`\r\n     * - `#with~symbols` becomes `#with\\\\~symbols`\r\n     *\r\n     * - More information about  the topic can be found at\r\n     *   https://mathiasbynens.be/notes/html5-id-class.\r\n     * - Practical example: https://mathiasbynens.be/demo/html5-id\r\n     */\n    if (process.env.NODE_ENV !== 'production' && typeof position.el === 'string') {\n      if (!isIdSelector || !document.getElementById(position.el.slice(1))) {\n        try {\n          const foundEl = document.querySelector(position.el);\n          if (isIdSelector && foundEl) {\n            warn(`The selector \"${position.el}\" should be passed as \"el: document.querySelector('${position.el}')\" because it starts with \"#\".`);\n            // return to avoid other warnings\n            return;\n          }\n        } catch (err) {\n          warn(`The selector \"${position.el}\" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);\n          // return to avoid other warnings\n          return;\n        }\n      }\n    }\n    const el = typeof positionEl === 'string' ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;\n    if (!el) {\n      process.env.NODE_ENV !== 'production' && warn(`Couldn't find element using selector \"${position.el}\" returned by scrollBehavior.`);\n      return;\n    }\n    scrollToOptions = getElementPosition(el, position);\n  } else {\n    scrollToOptions = position;\n  }\n  if ('scrollBehavior' in document.documentElement.style) window.scrollTo(scrollToOptions);else {\n    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);\n  }\n}\nfunction getScrollKey(path, delta) {\n  const position = history.state ? history.state.position - delta : -1;\n  return position + path;\n}\nconst scrollPositions = new Map();\nfunction saveScrollPosition(key, scrollPosition) {\n  scrollPositions.set(key, scrollPosition);\n}\nfunction getSavedScrollPosition(key) {\n  const scroll = scrollPositions.get(key);\n  // consume it so it's not used again\n  scrollPositions.delete(key);\n  return scroll;\n}\n// TODO: RFC about how to save scroll position\n/**\r\n * ScrollBehavior instance used by the router to compute and restore the scroll\r\n * position when navigating.\r\n */\n// export interface ScrollHandler<ScrollPositionEntry extends HistoryStateValue, ScrollPosition extends ScrollPositionEntry> {\n//   // returns a scroll position that can be saved in history\n//   compute(): ScrollPositionEntry\n//   // can take an extended ScrollPositionEntry\n//   scroll(position: ScrollPosition): void\n// }\n// export const scrollHandler: ScrollHandler<ScrollPosition> = {\n//   compute: computeScroll,\n//   scroll: scrollToPosition,\n// }\n\nlet createBaseLocation = () => location.protocol + '//' + location.host;\n/**\r\n * Creates a normalized history location from a window.location object\r\n * @param location -\r\n */\nfunction createCurrentLocation(base, location) {\n  const {\n    pathname,\n    search,\n    hash\n  } = location;\n  // allows hash bases like #, /#, #/, #!, #!/, /#!/, or even /folder#end\n  const hashPos = base.indexOf('#');\n  if (hashPos > -1) {\n    let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;\n    let pathFromHash = hash.slice(slicePos);\n    // prepend the starting slash to hash so the url starts with /#\n    if (pathFromHash[0] !== '/') pathFromHash = '/' + pathFromHash;\n    return stripBase(pathFromHash, '');\n  }\n  const path = stripBase(pathname, base);\n  return path + search + hash;\n}\nfunction useHistoryListeners(base, historyState, currentLocation, replace) {\n  let listeners = [];\n  let teardowns = [];\n  // TODO: should it be a stack? a Dict. Check if the popstate listener\n  // can trigger twice\n  let pauseState = null;\n  const popStateHandler = ({\n    state\n  }) => {\n    const to = createCurrentLocation(base, location);\n    const from = currentLocation.value;\n    const fromState = historyState.value;\n    let delta = 0;\n    if (state) {\n      currentLocation.value = to;\n      historyState.value = state;\n      // ignore the popstate and reset the pauseState\n      if (pauseState && pauseState === from) {\n        pauseState = null;\n        return;\n      }\n      delta = fromState ? state.position - fromState.position : 0;\n    } else {\n      replace(to);\n    }\n    // console.log({ deltaFromCurrent })\n    // Here we could also revert the navigation by calling history.go(-delta)\n    // this listener will have to be adapted to not trigger again and to wait for the url\n    // to be updated before triggering the listeners. Some kind of validation function would also\n    // need to be passed to the listeners so the navigation can be accepted\n    // call all listeners\n    listeners.forEach(listener => {\n      listener(currentLocation.value, from, {\n        delta,\n        type: NavigationType.pop,\n        direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown\n      });\n    });\n  };\n  function pauseListeners() {\n    pauseState = currentLocation.value;\n  }\n  function listen(callback) {\n    // setup the listener and prepare teardown callbacks\n    listeners.push(callback);\n    const teardown = () => {\n      const index = listeners.indexOf(callback);\n      if (index > -1) listeners.splice(index, 1);\n    };\n    teardowns.push(teardown);\n    return teardown;\n  }\n  function beforeUnloadListener() {\n    const {\n      history\n    } = window;\n    if (!history.state) return;\n    history.replaceState(assign({}, history.state, {\n      scroll: computeScrollPosition()\n    }), '');\n  }\n  function destroy() {\n    for (const teardown of teardowns) teardown();\n    teardowns = [];\n    window.removeEventListener('popstate', popStateHandler);\n    window.removeEventListener('beforeunload', beforeUnloadListener);\n  }\n  // setup the listeners and prepare teardown callbacks\n  window.addEventListener('popstate', popStateHandler);\n  window.addEventListener('beforeunload', beforeUnloadListener);\n  return {\n    pauseListeners,\n    listen,\n    destroy\n  };\n}\n/**\r\n * Creates a state object\r\n */\nfunction buildState(back, current, forward, replaced = false, computeScroll = false) {\n  return {\n    back,\n    current,\n    forward,\n    replaced,\n    position: window.history.length,\n    scroll: computeScroll ? computeScrollPosition() : null\n  };\n}\nfunction useHistoryStateNavigation(base) {\n  const {\n    history,\n    location\n  } = window;\n  // private variables\n  const currentLocation = {\n    value: createCurrentLocation(base, location)\n  };\n  const historyState = {\n    value: history.state\n  };\n  // build current history entry as this is a fresh navigation\n  if (!historyState.value) {\n    changeLocation(currentLocation.value, {\n      back: null,\n      current: currentLocation.value,\n      forward: null,\n      // the length is off by one, we need to decrease it\n      position: history.length - 1,\n      replaced: true,\n      // don't add a scroll as the user may have an anchor and we want\n      // scrollBehavior to be triggered without a saved position\n      scroll: null\n    }, true);\n  }\n  function changeLocation(to, state, replace) {\n    /**\r\n     * if a base tag is provided and we are on a normal domain, we have to\r\n     * respect the provided `base` attribute because pushState() will use it and\r\n     * potentially erase anything before the `#` like at\r\n     * https://github.com/vuejs/router/issues/685 where a base of\r\n     * `/folder/#` but a base of `/` would erase the `/folder/` section. If\r\n     * there is no host, the `<base>` tag makes no sense and if there isn't a\r\n     * base tag we can just use everything after the `#`.\r\n     */\n    const hashIndex = base.indexOf('#');\n    const url = hashIndex > -1 ? (location.host && document.querySelector('base') ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;\n    try {\n      // BROWSER QUIRK\n      // NOTE: Safari throws a SecurityError when calling this function 100 times in 30 seconds\n      history[replace ? 'replaceState' : 'pushState'](state, '', url);\n      historyState.value = state;\n    } catch (err) {\n      if (process.env.NODE_ENV !== 'production') {\n        warn('Error with push/replace State', err);\n      } else {\n        console.error(err);\n      }\n      // Force the navigation, this also resets the call count\n      location[replace ? 'replace' : 'assign'](url);\n    }\n  }\n  function replace(to, data) {\n    const state = assign({}, history.state, buildState(historyState.value.back,\n    // keep back and forward entries but override current position\n    to, historyState.value.forward, true), data, {\n      position: historyState.value.position\n    });\n    changeLocation(to, state, true);\n    currentLocation.value = to;\n  }\n  function push(to, data) {\n    // Add to current entry the information of where we are going\n    // as well as saving the current position\n    const currentState = assign({},\n    // use current history state to gracefully handle a wrong call to\n    // history.replaceState\n    // https://github.com/vuejs/router/issues/366\n    historyState.value, history.state, {\n      forward: to,\n      scroll: computeScrollPosition()\n    });\n    if (process.env.NODE_ENV !== 'production' && !history.state) {\n      warn(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\\n\\n` + `history.replaceState(history.state, '', url)\\n\\n` + `You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`);\n    }\n    changeLocation(currentState.current, currentState, true);\n    const state = assign({}, buildState(currentLocation.value, to, null), {\n      position: currentState.position + 1\n    }, data);\n    changeLocation(to, state, false);\n    currentLocation.value = to;\n  }\n  return {\n    location: currentLocation,\n    state: historyState,\n    push,\n    replace\n  };\n}\n/**\r\n * Creates an HTML5 history. Most common history for single page applications.\r\n *\r\n * @param base -\r\n */\nfunction createWebHistory(base) {\n  base = normalizeBase(base);\n  const historyNavigation = useHistoryStateNavigation(base);\n  const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);\n  function go(delta, triggerListeners = true) {\n    if (!triggerListeners) historyListeners.pauseListeners();\n    history.go(delta);\n  }\n  const routerHistory = assign({\n    // it's overridden right after\n    location: '',\n    base,\n    go,\n    createHref: createHref.bind(null, base)\n  }, historyNavigation, historyListeners);\n  Object.defineProperty(routerHistory, 'location', {\n    enumerable: true,\n    get: () => historyNavigation.location.value\n  });\n  Object.defineProperty(routerHistory, 'state', {\n    enumerable: true,\n    get: () => historyNavigation.state.value\n  });\n  return routerHistory;\n}\n\n/**\r\n * Creates a in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.\r\n * It's up to the user to replace that location with the starter location by either calling `router.push` or `router.replace`.\r\n *\r\n * @param base - Base applied to all urls, defaults to '/'\r\n * @returns a history object that can be passed to the router constructor\r\n */\nfunction createMemoryHistory(base = '') {\n  let listeners = [];\n  let queue = [START];\n  let position = 0;\n  base = normalizeBase(base);\n  function setLocation(location) {\n    position++;\n    if (position === queue.length) {\n      // we are at the end, we can simply append a new entry\n      queue.push(location);\n    } else {\n      // we are in the middle, we remove everything from here in the queue\n      queue.splice(position);\n      queue.push(location);\n    }\n  }\n  function triggerListeners(to, from, {\n    direction,\n    delta\n  }) {\n    const info = {\n      direction,\n      delta,\n      type: NavigationType.pop\n    };\n    for (const callback of listeners) {\n      callback(to, from, info);\n    }\n  }\n  const routerHistory = {\n    // rewritten by Object.defineProperty\n    location: START,\n    // TODO: should be kept in queue\n    state: {},\n    base,\n    createHref: createHref.bind(null, base),\n    replace(to) {\n      // remove current entry and decrement position\n      queue.splice(position--, 1);\n      setLocation(to);\n    },\n    push(to, data) {\n      setLocation(to);\n    },\n    listen(callback) {\n      listeners.push(callback);\n      return () => {\n        const index = listeners.indexOf(callback);\n        if (index > -1) listeners.splice(index, 1);\n      };\n    },\n    destroy() {\n      listeners = [];\n      queue = [START];\n      position = 0;\n    },\n    go(delta, shouldTrigger = true) {\n      const from = this.location;\n      const direction =\n      // we are considering delta === 0 going forward, but in abstract mode\n      // using 0 for the delta doesn't make sense like it does in html5 where\n      // it reloads the page\n      delta < 0 ? NavigationDirection.back : NavigationDirection.forward;\n      position = Math.max(0, Math.min(position + delta, queue.length - 1));\n      if (shouldTrigger) {\n        triggerListeners(this.location, from, {\n          direction,\n          delta\n        });\n      }\n    }\n  };\n  Object.defineProperty(routerHistory, 'location', {\n    enumerable: true,\n    get: () => queue[position]\n  });\n  return routerHistory;\n}\n\n/**\r\n * Creates a hash history. Useful for web applications with no host (e.g.\r\n * `file://`) or when configuring a server to handle any URL is not possible.\r\n *\r\n * @param base - optional base to provide. Defaults to `location.pathname +\r\n * location.search` If there is a `<base>` tag in the `head`, its value will be\r\n * ignored in favor of this parameter **but note it affects all the\r\n * history.pushState() calls**, meaning that if you use a `<base>` tag, it's\r\n * `href` value **has to match this parameter** (ignoring anything after the\r\n * `#`).\r\n *\r\n * @example\r\n * ```js\r\n * // at https://example.com/folder\r\n * createWebHashHistory() // gives a url of `https://example.com/folder#`\r\n * createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`\r\n * // if the `#` is provided in the base, it won't be added by `createWebHashHistory`\r\n * createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`\r\n * // you should avoid doing this because it changes the original url and breaks copying urls\r\n * createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`\r\n *\r\n * // at file:///usr/etc/folder/index.html\r\n * // for locations with no `host`, the base is ignored\r\n * createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`\r\n * ```\r\n */\nfunction createWebHashHistory(base) {\n  // Make sure this implementation is fine in terms of encoding, specially for IE11\n  // for `file://`, directly use the pathname and ignore the base\n  // location.pathname contains an initial `/` even at the root: `https://example.com`\n  base = location.host ? base || location.pathname + location.search : '';\n  // allow the user to provide a `#` in the middle: `/base/#/app`\n  if (!base.includes('#')) base += '#';\n  if (process.env.NODE_ENV !== 'production' && !base.endsWith('#/') && !base.endsWith('#')) {\n    warn(`A hash base must end with a \"#\":\\n\"${base}\" should be \"${base.replace(/#.*$/, '#')}\".`);\n  }\n  return createWebHistory(base);\n}\nfunction isRouteLocation(route) {\n  return typeof route === 'string' || route && typeof route === 'object';\n}\nfunction isRouteName(name) {\n  return typeof name === 'string' || typeof name === 'symbol';\n}\n\n/**\r\n * Initial route location where the router is. Can be used in navigation guards\r\n * to differentiate the initial navigation.\r\n *\r\n * @example\r\n * ```js\r\n * import { START_LOCATION } from 'vue-router'\r\n *\r\n * router.beforeEach((to, from) => {\r\n *   if (from === START_LOCATION) {\r\n *     // initial navigation\r\n *   }\r\n * })\r\n * ```\r\n */\nconst START_LOCATION_NORMALIZED = {\n  path: '/',\n  name: undefined,\n  params: {},\n  query: {},\n  hash: '',\n  fullPath: '/',\n  matched: [],\n  meta: {},\n  redirectedFrom: undefined\n};\nconst NavigationFailureSymbol = /*#__PURE__*/PolySymbol(process.env.NODE_ENV !== 'production' ? 'navigation failure' : 'nf');\n/**\r\n * Enumeration with all possible types for navigation failures. Can be passed to\r\n * {@link isNavigationFailure} to check for specific failures.\r\n */\nvar NavigationFailureType;\n(function (NavigationFailureType) {\n  /**\r\n   * An aborted navigation is a navigation that failed because a navigation\r\n   * guard returned `false` or called `next(false)`\r\n   */\n  NavigationFailureType[NavigationFailureType[\"aborted\"] = 4] = \"aborted\";\n  /**\r\n   * A cancelled navigation is a navigation that failed because a more recent\r\n   * navigation finished started (not necessarily finished).\r\n   */\n  NavigationFailureType[NavigationFailureType[\"cancelled\"] = 8] = \"cancelled\";\n  /**\r\n   * A duplicated navigation is a navigation that failed because it was\r\n   * initiated while already being at the exact same location.\r\n   */\n  NavigationFailureType[NavigationFailureType[\"duplicated\"] = 16] = \"duplicated\";\n})(NavigationFailureType || (NavigationFailureType = {}));\n// DEV only debug messages\nconst ErrorTypeMessages = {\n  [1 /* MATCHER_NOT_FOUND */]({\n    location,\n    currentLocation\n  }) {\n    return `No match for\\n ${JSON.stringify(location)}${currentLocation ? '\\nwhile being at\\n' + JSON.stringify(currentLocation) : ''}`;\n  },\n  [2 /* NAVIGATION_GUARD_REDIRECT */]({\n    from,\n    to\n  }) {\n    return `Redirected from \"${from.fullPath}\" to \"${stringifyRoute(to)}\" via a navigation guard.`;\n  },\n  [4 /* NAVIGATION_ABORTED */]({\n    from,\n    to\n  }) {\n    return `Navigation aborted from \"${from.fullPath}\" to \"${to.fullPath}\" via a navigation guard.`;\n  },\n  [8 /* NAVIGATION_CANCELLED */]({\n    from,\n    to\n  }) {\n    return `Navigation cancelled from \"${from.fullPath}\" to \"${to.fullPath}\" with a new navigation.`;\n  },\n  [16 /* NAVIGATION_DUPLICATED */]({\n    from,\n    to\n  }) {\n    return `Avoided redundant navigation to current location: \"${from.fullPath}\".`;\n  }\n};\nfunction createRouterError(type, params) {\n  // keep full error messages in cjs versions\n  if (process.env.NODE_ENV !== 'production' || !true) {\n    return assign(new Error(ErrorTypeMessages[type](params)), {\n      type,\n      [NavigationFailureSymbol]: true\n    }, params);\n  } else {\n    return assign(new Error(), {\n      type,\n      [NavigationFailureSymbol]: true\n    }, params);\n  }\n}\nfunction isNavigationFailure(error, type) {\n  return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));\n}\nconst propertiesToLog = ['params', 'query', 'hash'];\nfunction stringifyRoute(to) {\n  if (typeof to === 'string') return to;\n  if ('path' in to) return to.path;\n  const location = {};\n  for (const key of propertiesToLog) {\n    if (key in to) location[key] = to[key];\n  }\n  return JSON.stringify(location, null, 2);\n}\n\n// default pattern for a param: non greedy everything but /\nconst BASE_PARAM_PATTERN = '[^/]+?';\nconst BASE_PATH_PARSER_OPTIONS = {\n  sensitive: false,\n  strict: false,\n  start: true,\n  end: true\n};\n// Special Regex characters that must be escaped in static tokens\nconst REGEX_CHARS_RE = /[.+*?^${}()[\\]/\\\\]/g;\n/**\r\n * Creates a path parser from an array of Segments (a segment is an array of Tokens)\r\n *\r\n * @param segments - array of segments returned by tokenizePath\r\n * @param extraOptions - optional options for the regexp\r\n * @returns a PathParser\r\n */\nfunction tokensToParser(segments, extraOptions) {\n  const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);\n  // the amount of scores is the same as the length of segments except for the root segment \"/\"\n  const score = [];\n  // the regexp as a string\n  let pattern = options.start ? '^' : '';\n  // extracted keys\n  const keys = [];\n  for (const segment of segments) {\n    // the root segment needs special treatment\n    const segmentScores = segment.length ? [] : [90 /* Root */];\n    // allow trailing slash\n    if (options.strict && !segment.length) pattern += '/';\n    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {\n      const token = segment[tokenIndex];\n      // resets the score if we are inside a sub segment /:a-other-:b\n      let subSegmentScore = 40 /* Segment */ + (options.sensitive ? 0.25 /* BonusCaseSensitive */ : 0);\n      if (token.type === 0 /* Static */) {\n        // prepend the slash if we are starting a new segment\n        if (!tokenIndex) pattern += '/';\n        pattern += token.value.replace(REGEX_CHARS_RE, '\\\\$&');\n        subSegmentScore += 40 /* Static */;\n      } else if (token.type === 1 /* Param */) {\n        const {\n          value,\n          repeatable,\n          optional,\n          regexp\n        } = token;\n        keys.push({\n          name: value,\n          repeatable,\n          optional\n        });\n        const re = regexp ? regexp : BASE_PARAM_PATTERN;\n        // the user provided a custom regexp /:id(\\\\d+)\n        if (re !== BASE_PARAM_PATTERN) {\n          subSegmentScore += 10 /* BonusCustomRegExp */;\n          // make sure the regexp is valid before using it\n          try {\n            new RegExp(`(${re})`);\n          } catch (err) {\n            throw new Error(`Invalid custom RegExp for param \"${value}\" (${re}): ` + err.message);\n          }\n        }\n        // when we repeat we must take care of the repeating leading slash\n        let subPattern = repeatable ? `((?:${re})(?:/(?:${re}))*)` : `(${re})`;\n        // prepend the slash if we are starting a new segment\n        if (!tokenIndex) subPattern =\n        // avoid an optional / if there are more segments e.g. /:p?-static\n        // or /:p?-:p2\n        optional && segment.length < 2 ? `(?:/${subPattern})` : '/' + subPattern;\n        if (optional) subPattern += '?';\n        pattern += subPattern;\n        subSegmentScore += 20 /* Dynamic */;\n        if (optional) subSegmentScore += -8 /* BonusOptional */;\n        if (repeatable) subSegmentScore += -20 /* BonusRepeatable */;\n        if (re === '.*') subSegmentScore += -50 /* BonusWildcard */;\n      }\n      segmentScores.push(subSegmentScore);\n    }\n    // an empty array like /home/ -> [[{home}], []]\n    // if (!segment.length) pattern += '/'\n    score.push(segmentScores);\n  }\n  // only apply the strict bonus to the last score\n  if (options.strict && options.end) {\n    const i = score.length - 1;\n    score[i][score[i].length - 1] += 0.7000000000000001 /* BonusStrict */;\n  }\n  // TODO: dev only warn double trailing slash\n  if (!options.strict) pattern += '/?';\n  if (options.end) pattern += '$';\n  // allow paths like /dynamic to only match dynamic or dynamic/... but not dynamic_something_else\n  else if (options.strict) pattern += '(?:/|$)';\n  const re = new RegExp(pattern, options.sensitive ? '' : 'i');\n  function parse(path) {\n    const match = path.match(re);\n    const params = {};\n    if (!match) return null;\n    for (let i = 1; i < match.length; i++) {\n      const value = match[i] || '';\n      const key = keys[i - 1];\n      params[key.name] = value && key.repeatable ? value.split('/') : value;\n    }\n    return params;\n  }\n  function stringify(params) {\n    let path = '';\n    // for optional parameters to allow to be empty\n    let avoidDuplicatedSlash = false;\n    for (const segment of segments) {\n      if (!avoidDuplicatedSlash || !path.endsWith('/')) path += '/';\n      avoidDuplicatedSlash = false;\n      for (const token of segment) {\n        if (token.type === 0 /* Static */) {\n          path += token.value;\n        } else if (token.type === 1 /* Param */) {\n          const {\n            value,\n            repeatable,\n            optional\n          } = token;\n          const param = value in params ? params[value] : '';\n          if (Array.isArray(param) && !repeatable) throw new Error(`Provided param \"${value}\" is an array but it is not repeatable (* or + modifiers)`);\n          const text = Array.isArray(param) ? param.join('/') : param;\n          if (!text) {\n            if (optional) {\n              // if we have more than one optional param like /:a?-static we\n              // don't need to care about the optional param\n              if (segment.length < 2) {\n                // remove the last slash as we could be at the end\n                if (path.endsWith('/')) path = path.slice(0, -1);\n                // do not append a slash on the next iteration\n                else avoidDuplicatedSlash = true;\n              }\n            } else throw new Error(`Missing required param \"${value}\"`);\n          }\n          path += text;\n        }\n      }\n    }\n    return path;\n  }\n  return {\n    re,\n    score,\n    keys,\n    parse,\n    stringify\n  };\n}\n/**\r\n * Compares an array of numbers as used in PathParser.score and returns a\r\n * number. This function can be used to `sort` an array\r\n *\r\n * @param a - first array of numbers\r\n * @param b - second array of numbers\r\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\r\n * should be sorted first\r\n */\nfunction compareScoreArray(a, b) {\n  let i = 0;\n  while (i < a.length && i < b.length) {\n    const diff = b[i] - a[i];\n    // only keep going if diff === 0\n    if (diff) return diff;\n    i++;\n  }\n  // if the last subsegment was Static, the shorter segments should be sorted first\n  // otherwise sort the longest segment first\n  if (a.length < b.length) {\n    return a.length === 1 && a[0] === 40 /* Static */ + 40 /* Segment */ ? -1 : 1;\n  } else if (a.length > b.length) {\n    return b.length === 1 && b[0] === 40 /* Static */ + 40 /* Segment */ ? 1 : -1;\n  }\n  return 0;\n}\n/**\r\n * Compare function that can be used with `sort` to sort an array of PathParser\r\n *\r\n * @param a - first PathParser\r\n * @param b - second PathParser\r\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\r\n */\nfunction comparePathParserScore(a, b) {\n  let i = 0;\n  const aScore = a.score;\n  const bScore = b.score;\n  while (i < aScore.length && i < bScore.length) {\n    const comp = compareScoreArray(aScore[i], bScore[i]);\n    // do not return if both are equal\n    if (comp) return comp;\n    i++;\n  }\n  // if a and b share the same score entries but b has more, sort b first\n  return bScore.length - aScore.length;\n  // this is the ternary version\n  // return aScore.length < bScore.length\n  //   ? 1\n  //   : aScore.length > bScore.length\n  //   ? -1\n  //   : 0\n}\nconst ROOT_TOKEN = {\n  type: 0 /* Static */,\n  value: ''\n};\nconst VALID_PARAM_RE = /[a-zA-Z0-9_]/;\n// After some profiling, the cache seems to be unnecessary because tokenizePath\n// (the slowest part of adding a route) is very fast\n// const tokenCache = new Map<string, Token[][]>()\nfunction tokenizePath(path) {\n  if (!path) return [[]];\n  if (path === '/') return [[ROOT_TOKEN]];\n  if (!path.startsWith('/')) {\n    throw new Error(process.env.NODE_ENV !== 'production' ? `Route paths should start with a \"/\": \"${path}\" should be \"/${path}\".` : `Invalid path \"${path}\"`);\n  }\n  // if (tokenCache.has(path)) return tokenCache.get(path)!\n  function crash(message) {\n    throw new Error(`ERR (${state})/\"${buffer}\": ${message}`);\n  }\n  let state = 0 /* Static */;\n  let previousState = state;\n  const tokens = [];\n  // the segment will always be valid because we get into the initial state\n  // with the leading /\n  let segment;\n  function finalizeSegment() {\n    if (segment) tokens.push(segment);\n    segment = [];\n  }\n  // index on the path\n  let i = 0;\n  // char at index\n  let char;\n  // buffer of the value read\n  let buffer = '';\n  // custom regexp for a param\n  let customRe = '';\n  function consumeBuffer() {\n    if (!buffer) return;\n    if (state === 0 /* Static */) {\n      segment.push({\n        type: 0 /* Static */,\n        value: buffer\n      });\n    } else if (state === 1 /* Param */ || state === 2 /* ParamRegExp */ || state === 3 /* ParamRegExpEnd */) {\n      if (segment.length > 1 && (char === '*' || char === '+')) crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);\n      segment.push({\n        type: 1 /* Param */,\n        value: buffer,\n        regexp: customRe,\n        repeatable: char === '*' || char === '+',\n        optional: char === '*' || char === '?'\n      });\n    } else {\n      crash('Invalid state to consume buffer');\n    }\n    buffer = '';\n  }\n  function addCharToBuffer() {\n    buffer += char;\n  }\n  while (i < path.length) {\n    char = path[i++];\n    if (char === '\\\\' && state !== 2 /* ParamRegExp */) {\n      previousState = state;\n      state = 4 /* EscapeNext */;\n      continue;\n    }\n    switch (state) {\n      case 0 /* Static */:\n        if (char === '/') {\n          if (buffer) {\n            consumeBuffer();\n          }\n          finalizeSegment();\n        } else if (char === ':') {\n          consumeBuffer();\n          state = 1 /* Param */;\n        } else {\n          addCharToBuffer();\n        }\n        break;\n      case 4 /* EscapeNext */:\n        addCharToBuffer();\n        state = previousState;\n        break;\n      case 1 /* Param */:\n        if (char === '(') {\n          state = 2 /* ParamRegExp */;\n        } else if (VALID_PARAM_RE.test(char)) {\n          addCharToBuffer();\n        } else {\n          consumeBuffer();\n          state = 0 /* Static */;\n          // go back one character if we were not modifying\n          if (char !== '*' && char !== '?' && char !== '+') i--;\n        }\n        break;\n      case 2 /* ParamRegExp */:\n        // TODO: is it worth handling nested regexp? like :p(?:prefix_([^/]+)_suffix)\n        // it already works by escaping the closing )\n        // https://paths.esm.dev/?p=AAMeJbiAwQEcDKbAoAAkP60PG2R6QAvgNaA6AFACM2ABuQBB#\n        // is this really something people need since you can also write\n        // /prefix_:p()_suffix\n        if (char === ')') {\n          // handle the escaped )\n          if (customRe[customRe.length - 1] == '\\\\') customRe = customRe.slice(0, -1) + char;else state = 3 /* ParamRegExpEnd */;\n        } else {\n          customRe += char;\n        }\n        break;\n      case 3 /* ParamRegExpEnd */:\n        // same as finalizing a param\n        consumeBuffer();\n        state = 0 /* Static */;\n        // go back one character if we were not modifying\n        if (char !== '*' && char !== '?' && char !== '+') i--;\n        customRe = '';\n        break;\n      default:\n        crash('Unknown state');\n        break;\n    }\n  }\n  if (state === 2 /* ParamRegExp */) crash(`Unfinished custom RegExp for param \"${buffer}\"`);\n  consumeBuffer();\n  finalizeSegment();\n  // tokenCache.set(path, tokens)\n  return tokens;\n}\nfunction createRouteRecordMatcher(record, parent, options) {\n  const parser = tokensToParser(tokenizePath(record.path), options);\n  // warn against params with the same name\n  if (process.env.NODE_ENV !== 'production') {\n    const existingKeys = new Set();\n    for (const key of parser.keys) {\n      if (existingKeys.has(key.name)) warn(`Found duplicated params with name \"${key.name}\" for path \"${record.path}\". Only the last one will be available on \"$route.params\".`);\n      existingKeys.add(key.name);\n    }\n  }\n  const matcher = assign(parser, {\n    record,\n    parent,\n    // these needs to be populated by the parent\n    children: [],\n    alias: []\n  });\n  if (parent) {\n    // both are aliases or both are not aliases\n    // we don't want to mix them because the order is used when\n    // passing originalRecord in Matcher.addRoute\n    if (!matcher.record.aliasOf === !parent.record.aliasOf) parent.children.push(matcher);\n  }\n  return matcher;\n}\n\n/**\r\n * Creates a Router Matcher.\r\n *\r\n * @internal\r\n * @param routes - array of initial routes\r\n * @param globalOptions - global route options\r\n */\nfunction createRouterMatcher(routes, globalOptions) {\n  // normalized ordered array of matchers\n  const matchers = [];\n  const matcherMap = new Map();\n  globalOptions = mergeOptions({\n    strict: false,\n    end: true,\n    sensitive: false\n  }, globalOptions);\n  function getRecordMatcher(name) {\n    return matcherMap.get(name);\n  }\n  function addRoute(record, parent, originalRecord) {\n    // used later on to remove by name\n    const isRootAdd = !originalRecord;\n    const mainNormalizedRecord = normalizeRouteRecord(record);\n    // we might be the child of an alias\n    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;\n    const options = mergeOptions(globalOptions, record);\n    // generate an array of records to correctly handle aliases\n    const normalizedRecords = [mainNormalizedRecord];\n    if ('alias' in record) {\n      const aliases = typeof record.alias === 'string' ? [record.alias] : record.alias;\n      for (const alias of aliases) {\n        normalizedRecords.push(assign({}, mainNormalizedRecord, {\n          // this allows us to hold a copy of the `components` option\n          // so that async components cache is hold on the original record\n          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,\n          path: alias,\n          // we might be the child of an alias\n          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord\n          // the aliases are always of the same kind as the original since they\n          // are defined on the same record\n        }));\n      }\n    }\n    let matcher;\n    let originalMatcher;\n    for (const normalizedRecord of normalizedRecords) {\n      const {\n        path\n      } = normalizedRecord;\n      // Build up the path for nested routes if the child isn't an absolute\n      // route. Only add the / delimiter if the child path isn't empty and if the\n      // parent path doesn't have a trailing slash\n      if (parent && path[0] !== '/') {\n        const parentPath = parent.record.path;\n        const connectingSlash = parentPath[parentPath.length - 1] === '/' ? '' : '/';\n        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);\n      }\n      if (process.env.NODE_ENV !== 'production' && normalizedRecord.path === '*') {\n        throw new Error('Catch all routes (\"*\") must now be defined using a param with a custom regexp.\\n' + 'See more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.');\n      }\n      // create the object before hand so it can be passed to children\n      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);\n      if (process.env.NODE_ENV !== 'production' && parent && path[0] === '/') checkMissingParamsInAbsolutePath(matcher, parent);\n      // if we are an alias we must tell the original record that we exist\n      // so we can be removed\n      if (originalRecord) {\n        originalRecord.alias.push(matcher);\n        if (process.env.NODE_ENV !== 'production') {\n          checkSameParams(originalRecord, matcher);\n        }\n      } else {\n        // otherwise, the first record is the original and others are aliases\n        originalMatcher = originalMatcher || matcher;\n        if (originalMatcher !== matcher) originalMatcher.alias.push(matcher);\n        // remove the route if named and only for the top record (avoid in nested calls)\n        // this works because the original record is the first one\n        if (isRootAdd && record.name && !isAliasRecord(matcher)) removeRoute(record.name);\n      }\n      if ('children' in mainNormalizedRecord) {\n        const children = mainNormalizedRecord.children;\n        for (let i = 0; i < children.length; i++) {\n          addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);\n        }\n      }\n      // if there was no original record, then the first one was not an alias and all\n      // other alias (if any) need to reference this record when adding children\n      originalRecord = originalRecord || matcher;\n      // TODO: add normalized records for more flexibility\n      // if (parent && isAliasRecord(originalRecord)) {\n      //   parent.children.push(originalRecord)\n      // }\n      insertMatcher(matcher);\n    }\n    return originalMatcher ? () => {\n      // since other matchers are aliases, they should be removed by the original matcher\n      removeRoute(originalMatcher);\n    } : noop;\n  }\n  function removeRoute(matcherRef) {\n    if (isRouteName(matcherRef)) {\n      const matcher = matcherMap.get(matcherRef);\n      if (matcher) {\n        matcherMap.delete(matcherRef);\n        matchers.splice(matchers.indexOf(matcher), 1);\n        matcher.children.forEach(removeRoute);\n        matcher.alias.forEach(removeRoute);\n      }\n    } else {\n      const index = matchers.indexOf(matcherRef);\n      if (index > -1) {\n        matchers.splice(index, 1);\n        if (matcherRef.record.name) matcherMap.delete(matcherRef.record.name);\n        matcherRef.children.forEach(removeRoute);\n        matcherRef.alias.forEach(removeRoute);\n      }\n    }\n  }\n  function getRoutes() {\n    return matchers;\n  }\n  function insertMatcher(matcher) {\n    let i = 0;\n    while (i < matchers.length && comparePathParserScore(matcher, matchers[i]) >= 0 && (\n    // Adding children with empty path should still appear before the parent\n    // https://github.com/vuejs/router/issues/1124\n    matcher.record.path !== matchers[i].record.path || !isRecordChildOf(matcher, matchers[i]))) i++;\n    matchers.splice(i, 0, matcher);\n    // only add the original record to the name map\n    if (matcher.record.name && !isAliasRecord(matcher)) matcherMap.set(matcher.record.name, matcher);\n  }\n  function resolve(location, currentLocation) {\n    let matcher;\n    let params = {};\n    let path;\n    let name;\n    if ('name' in location && location.name) {\n      matcher = matcherMap.get(location.name);\n      if (!matcher) throw createRouterError(1 /* MATCHER_NOT_FOUND */, {\n        location\n      });\n      name = matcher.record.name;\n      params = assign(\n      // paramsFromLocation is a new object\n      paramsFromLocation(currentLocation.params,\n      // only keep params that exist in the resolved location\n      // TODO: only keep optional params coming from a parent record\n      matcher.keys.filter(k => !k.optional).map(k => k.name)), location.params);\n      // throws if cannot be stringified\n      path = matcher.stringify(params);\n    } else if ('path' in location) {\n      // no need to resolve the path with the matcher as it was provided\n      // this also allows the user to control the encoding\n      path = location.path;\n      if (process.env.NODE_ENV !== 'production' && !path.startsWith('/')) {\n        warn(`The Matcher cannot resolve relative paths but received \"${path}\". Unless you directly called \\`matcher.resolve(\"${path}\")\\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/router.`);\n      }\n      matcher = matchers.find(m => m.re.test(path));\n      // matcher should have a value after the loop\n      if (matcher) {\n        // TODO: dev warning of unused params if provided\n        // we know the matcher works because we tested the regexp\n        params = matcher.parse(path);\n        name = matcher.record.name;\n      }\n      // location is a relative path\n    } else {\n      // match by name or path of current route\n      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find(m => m.re.test(currentLocation.path));\n      if (!matcher) throw createRouterError(1 /* MATCHER_NOT_FOUND */, {\n        location,\n        currentLocation\n      });\n      name = matcher.record.name;\n      // since we are navigating to the same location, we don't need to pick the\n      // params like when `name` is provided\n      params = assign({}, currentLocation.params, location.params);\n      path = matcher.stringify(params);\n    }\n    const matched = [];\n    let parentMatcher = matcher;\n    while (parentMatcher) {\n      // reversed order so parents are at the beginning\n      matched.unshift(parentMatcher.record);\n      parentMatcher = parentMatcher.parent;\n    }\n    return {\n      name,\n      path,\n      params,\n      matched,\n      meta: mergeMetaFields(matched)\n    };\n  }\n  // add initial routes\n  routes.forEach(route => addRoute(route));\n  return {\n    addRoute,\n    resolve,\n    removeRoute,\n    getRoutes,\n    getRecordMatcher\n  };\n}\nfunction paramsFromLocation(params, keys) {\n  const newParams = {};\n  for (const key of keys) {\n    if (key in params) newParams[key] = params[key];\n  }\n  return newParams;\n}\n/**\r\n * Normalizes a RouteRecordRaw. Creates a copy\r\n *\r\n * @param record\r\n * @returns the normalized version\r\n */\nfunction normalizeRouteRecord(record) {\n  return {\n    path: record.path,\n    redirect: record.redirect,\n    name: record.name,\n    meta: record.meta || {},\n    aliasOf: undefined,\n    beforeEnter: record.beforeEnter,\n    props: normalizeRecordProps(record),\n    children: record.children || [],\n    instances: {},\n    leaveGuards: new Set(),\n    updateGuards: new Set(),\n    enterCallbacks: {},\n    components: 'components' in record ? record.components || {} : {\n      default: record.component\n    }\n  };\n}\n/**\r\n * Normalize the optional `props` in a record to always be an object similar to\r\n * components. Also accept a boolean for components.\r\n * @param record\r\n */\nfunction normalizeRecordProps(record) {\n  const propsObject = {};\n  // props does not exist on redirect records but we can set false directly\n  const props = record.props || false;\n  if ('component' in record) {\n    propsObject.default = props;\n  } else {\n    // NOTE: we could also allow a function to be applied to every component.\n    // Would need user feedback for use cases\n    for (const name in record.components) propsObject[name] = typeof props === 'boolean' ? props : props[name];\n  }\n  return propsObject;\n}\n/**\r\n * Checks if a record or any of its parent is an alias\r\n * @param record\r\n */\nfunction isAliasRecord(record) {\n  while (record) {\n    if (record.record.aliasOf) return true;\n    record = record.parent;\n  }\n  return false;\n}\n/**\r\n * Merge meta fields of an array of records\r\n *\r\n * @param matched - array of matched records\r\n */\nfunction mergeMetaFields(matched) {\n  return matched.reduce((meta, record) => assign(meta, record.meta), {});\n}\nfunction mergeOptions(defaults, partialOptions) {\n  const options = {};\n  for (const key in defaults) {\n    options[key] = key in partialOptions ? partialOptions[key] : defaults[key];\n  }\n  return options;\n}\nfunction isSameParam(a, b) {\n  return a.name === b.name && a.optional === b.optional && a.repeatable === b.repeatable;\n}\n/**\r\n * Check if a path and its alias have the same required params\r\n *\r\n * @param a - original record\r\n * @param b - alias record\r\n */\nfunction checkSameParams(a, b) {\n  for (const key of a.keys) {\n    if (!key.optional && !b.keys.find(isSameParam.bind(null, key))) return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" should have the exact same param named \"${key.name}\"`);\n  }\n  for (const key of b.keys) {\n    if (!key.optional && !a.keys.find(isSameParam.bind(null, key))) return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" should have the exact same param named \"${key.name}\"`);\n  }\n}\nfunction checkMissingParamsInAbsolutePath(record, parent) {\n  for (const key of parent.keys) {\n    if (!record.keys.find(isSameParam.bind(null, key))) return warn(`Absolute path \"${record.record.path}\" should have the exact same param named \"${key.name}\" as its parent \"${parent.record.path}\".`);\n  }\n}\nfunction isRecordChildOf(record, parent) {\n  return parent.children.some(child => child === record || isRecordChildOf(record, child));\n}\n\n/**\r\n * Encoding Rules ␣ = Space Path: ␣ \" < > # ? { } Query: ␣ \" < > # & = Hash: ␣ \"\r\n * < > `\r\n *\r\n * On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)\r\n * defines some extra characters to be encoded. Most browsers do not encode them\r\n * in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to\r\n * also encode `!'()*`. Leaving unencoded only ASCII alphanumeric(`a-zA-Z0-9`)\r\n * plus `-._~`. This extra safety should be applied to query by patching the\r\n * string returned by encodeURIComponent encodeURI also encodes `[\\]^`. `\\`\r\n * should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\\`\r\n * into a `/` if directly typed in. The _backtick_ (`````) should also be\r\n * encoded everywhere because some browsers like FF encode it when directly\r\n * written while others don't. Safari and IE don't encode ``\"<>{}``` in hash.\r\n */\n// const EXTRA_RESERVED_RE = /[!'()*]/g\n// const encodeReservedReplacer = (c: string) => '%' + c.charCodeAt(0).toString(16)\nconst HASH_RE = /#/g; // %23\nconst AMPERSAND_RE = /&/g; // %26\nconst SLASH_RE = /\\//g; // %2F\nconst EQUAL_RE = /=/g; // %3D\nconst IM_RE = /\\?/g; // %3F\nconst PLUS_RE = /\\+/g; // %2B\n/**\r\n * NOTE: It's not clear to me if we should encode the + symbol in queries, it\r\n * seems to be less flexible than not doing so and I can't find out the legacy\r\n * systems requiring this for regular requests like text/html. In the standard,\r\n * the encoding of the plus character is only mentioned for\r\n * application/x-www-form-urlencoded\r\n * (https://url.spec.whatwg.org/#urlencoded-parsing) and most browsers seems lo\r\n * leave the plus character as is in queries. To be more flexible, we allow the\r\n * plus character on the query but it can also be manually encoded by the user.\r\n *\r\n * Resources:\r\n * - https://url.spec.whatwg.org/#urlencoded-parsing\r\n * - https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20\r\n */\nconst ENC_BRACKET_OPEN_RE = /%5B/g; // [\nconst ENC_BRACKET_CLOSE_RE = /%5D/g; // ]\nconst ENC_CARET_RE = /%5E/g; // ^\nconst ENC_BACKTICK_RE = /%60/g; // `\nconst ENC_CURLY_OPEN_RE = /%7B/g; // {\nconst ENC_PIPE_RE = /%7C/g; // |\nconst ENC_CURLY_CLOSE_RE = /%7D/g; // }\nconst ENC_SPACE_RE = /%20/g; // }\n/**\r\n * Encode characters that need to be encoded on the path, search and hash\r\n * sections of the URL.\r\n *\r\n * @internal\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\nfunction commonEncode(text) {\n  return encodeURI('' + text).replace(ENC_PIPE_RE, '|').replace(ENC_BRACKET_OPEN_RE, '[').replace(ENC_BRACKET_CLOSE_RE, ']');\n}\n/**\r\n * Encode characters that need to be encoded on the hash section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\nfunction encodeHash(text) {\n  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, '{').replace(ENC_CURLY_CLOSE_RE, '}').replace(ENC_CARET_RE, '^');\n}\n/**\r\n * Encode characters that need to be encoded query values on the query\r\n * section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\nfunction encodeQueryValue(text) {\n  return commonEncode(text)\n  // Encode the space as +, encode the + to differentiate it from the space\n  .replace(PLUS_RE, '%2B').replace(ENC_SPACE_RE, '+').replace(HASH_RE, '%23').replace(AMPERSAND_RE, '%26').replace(ENC_BACKTICK_RE, '`').replace(ENC_CURLY_OPEN_RE, '{').replace(ENC_CURLY_CLOSE_RE, '}').replace(ENC_CARET_RE, '^');\n}\n/**\r\n * Like `encodeQueryValue` but also encodes the `=` character.\r\n *\r\n * @param text - string to encode\r\n */\nfunction encodeQueryKey(text) {\n  return encodeQueryValue(text).replace(EQUAL_RE, '%3D');\n}\n/**\r\n * Encode characters that need to be encoded on the path section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\nfunction encodePath(text) {\n  return commonEncode(text).replace(HASH_RE, '%23').replace(IM_RE, '%3F');\n}\n/**\r\n * Encode characters that need to be encoded on the path section of the URL as a\r\n * param. This function encodes everything {@link encodePath} does plus the\r\n * slash (`/`) character. If `text` is `null` or `undefined`, returns an empty\r\n * string instead.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\nfunction encodeParam(text) {\n  return text == null ? '' : encodePath(text).replace(SLASH_RE, '%2F');\n}\n/**\r\n * Decode text using `decodeURIComponent`. Returns the original text if it\r\n * fails.\r\n *\r\n * @param text - string to decode\r\n * @returns decoded string\r\n */\nfunction decode(text) {\n  try {\n    return decodeURIComponent('' + text);\n  } catch (err) {\n    process.env.NODE_ENV !== 'production' && warn(`Error decoding \"${text}\". Using original value`);\n  }\n  return '' + text;\n}\n\n/**\r\n * Transforms a queryString into a {@link LocationQuery} object. Accept both, a\r\n * version with the leading `?` and without Should work as URLSearchParams\r\n\r\n * @internal\r\n *\r\n * @param search - search string to parse\r\n * @returns a query object\r\n */\nfunction parseQuery(search) {\n  const query = {};\n  // avoid creating an object with an empty key and empty value\n  // because of split('&')\n  if (search === '' || search === '?') return query;\n  const hasLeadingIM = search[0] === '?';\n  const searchParams = (hasLeadingIM ? search.slice(1) : search).split('&');\n  for (let i = 0; i < searchParams.length; ++i) {\n    // pre decode the + into space\n    const searchParam = searchParams[i].replace(PLUS_RE, ' ');\n    // allow the = character\n    const eqPos = searchParam.indexOf('=');\n    const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));\n    const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));\n    if (key in query) {\n      // an extra variable for ts types\n      let currentValue = query[key];\n      if (!Array.isArray(currentValue)) {\n        currentValue = query[key] = [currentValue];\n      }\n      currentValue.push(value);\n    } else {\n      query[key] = value;\n    }\n  }\n  return query;\n}\n/**\r\n * Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it\r\n * doesn't prepend a `?`\r\n *\r\n * @internal\r\n *\r\n * @param query - query object to stringify\r\n * @returns string version of the query without the leading `?`\r\n */\nfunction stringifyQuery(query) {\n  let search = '';\n  for (let key in query) {\n    const value = query[key];\n    key = encodeQueryKey(key);\n    if (value == null) {\n      // only null adds the value\n      if (value !== undefined) {\n        search += (search.length ? '&' : '') + key;\n      }\n      continue;\n    }\n    // keep null values\n    const values = Array.isArray(value) ? value.map(v => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)];\n    values.forEach(value => {\n      // skip undefined values in arrays as if they were not present\n      // smaller code than using filter\n      if (value !== undefined) {\n        // only append & with non-empty search\n        search += (search.length ? '&' : '') + key;\n        if (value != null) search += '=' + value;\n      }\n    });\n  }\n  return search;\n}\n/**\r\n * Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting\r\n * numbers into strings, removing keys with an undefined value and replacing\r\n * undefined with null in arrays\r\n *\r\n * @param query - query object to normalize\r\n * @returns a normalized query object\r\n */\nfunction normalizeQuery(query) {\n  const normalizedQuery = {};\n  for (const key in query) {\n    const value = query[key];\n    if (value !== undefined) {\n      normalizedQuery[key] = Array.isArray(value) ? value.map(v => v == null ? null : '' + v) : value == null ? value : '' + value;\n    }\n  }\n  return normalizedQuery;\n}\n\n/**\r\n * Create a list of callbacks that can be reset. Used to create before and after navigation guards list\r\n */\nfunction useCallbacks() {\n  let handlers = [];\n  function add(handler) {\n    handlers.push(handler);\n    return () => {\n      const i = handlers.indexOf(handler);\n      if (i > -1) handlers.splice(i, 1);\n    };\n  }\n  function reset() {\n    handlers = [];\n  }\n  return {\n    add,\n    list: () => handlers,\n    reset\n  };\n}\nfunction registerGuard(record, name, guard) {\n  const removeFromList = () => {\n    record[name].delete(guard);\n  };\n  onUnmounted(removeFromList);\n  onDeactivated(removeFromList);\n  onActivated(() => {\n    record[name].add(guard);\n  });\n  record[name].add(guard);\n}\n/**\r\n * Add a navigation guard that triggers whenever the component for the current\r\n * location is about to be left. Similar to {@link beforeRouteLeave} but can be\r\n * used in any component. The guard is removed when the component is unmounted.\r\n *\r\n * @param leaveGuard - {@link NavigationGuard}\r\n */\nfunction onBeforeRouteLeave(leaveGuard) {\n  if (process.env.NODE_ENV !== 'production' && !getCurrentInstance()) {\n    warn('getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function');\n    return;\n  }\n  const activeRecord = inject(matchedRouteKey,\n  // to avoid warning\n  {}).value;\n  if (!activeRecord) {\n    process.env.NODE_ENV !== 'production' && warn('No active route record was found when calling `onBeforeRouteLeave()`. Make sure you call this function inside of a component child of <router-view>. Maybe you called it inside of App.vue?');\n    return;\n  }\n  registerGuard(activeRecord, 'leaveGuards', leaveGuard);\n}\n/**\r\n * Add a navigation guard that triggers whenever the current location is about\r\n * to be updated. Similar to {@link beforeRouteUpdate} but can be used in any\r\n * component. The guard is removed when the component is unmounted.\r\n *\r\n * @param updateGuard - {@link NavigationGuard}\r\n */\nfunction onBeforeRouteUpdate(updateGuard) {\n  if (process.env.NODE_ENV !== 'production' && !getCurrentInstance()) {\n    warn('getCurrentInstance() returned null. onBeforeRouteUpdate() must be called at the top of a setup function');\n    return;\n  }\n  const activeRecord = inject(matchedRouteKey,\n  // to avoid warning\n  {}).value;\n  if (!activeRecord) {\n    process.env.NODE_ENV !== 'production' && warn('No active route record was found when calling `onBeforeRouteUpdate()`. Make sure you call this function inside of a component child of <router-view>. Maybe you called it inside of App.vue?');\n    return;\n  }\n  registerGuard(activeRecord, 'updateGuards', updateGuard);\n}\nfunction guardToPromiseFn(guard, to, from, record, name) {\n  // keep a reference to the enterCallbackArray to prevent pushing callbacks if a new navigation took place\n  const enterCallbackArray = record && (\n  // name is defined if record is because of the function overload\n  record.enterCallbacks[name] = record.enterCallbacks[name] || []);\n  return () => new Promise((resolve, reject) => {\n    const next = valid => {\n      if (valid === false) reject(createRouterError(4 /* NAVIGATION_ABORTED */, {\n        from,\n        to\n      }));else if (valid instanceof Error) {\n        reject(valid);\n      } else if (isRouteLocation(valid)) {\n        reject(createRouterError(2 /* NAVIGATION_GUARD_REDIRECT */, {\n          from: to,\n          to: valid\n        }));\n      } else {\n        if (enterCallbackArray &&\n        // since enterCallbackArray is truthy, both record and name also are\n        record.enterCallbacks[name] === enterCallbackArray && typeof valid === 'function') enterCallbackArray.push(valid);\n        resolve();\n      }\n    };\n    // wrapping with Promise.resolve allows it to work with both async and sync guards\n    const guardReturn = guard.call(record && record.instances[name], to, from, process.env.NODE_ENV !== 'production' ? canOnlyBeCalledOnce(next, to, from) : next);\n    let guardCall = Promise.resolve(guardReturn);\n    if (guard.length < 3) guardCall = guardCall.then(next);\n    if (process.env.NODE_ENV !== 'production' && guard.length > 2) {\n      const message = `The \"next\" callback was never called inside of ${guard.name ? '\"' + guard.name + '\"' : ''}:\\n${guard.toString()}\\n. If you are returning a value instead of calling \"next\", make sure to remove the \"next\" parameter from your function.`;\n      if (typeof guardReturn === 'object' && 'then' in guardReturn) {\n        guardCall = guardCall.then(resolvedValue => {\n          // @ts-expect-error: _called is added at canOnlyBeCalledOnce\n          if (!next._called) {\n            warn(message);\n            return Promise.reject(new Error('Invalid navigation guard'));\n          }\n          return resolvedValue;\n        });\n        // TODO: test me!\n      } else if (guardReturn !== undefined) {\n        // @ts-expect-error: _called is added at canOnlyBeCalledOnce\n        if (!next._called) {\n          warn(message);\n          reject(new Error('Invalid navigation guard'));\n          return;\n        }\n      }\n    }\n    guardCall.catch(err => reject(err));\n  });\n}\nfunction canOnlyBeCalledOnce(next, to, from) {\n  let called = 0;\n  return function () {\n    if (called++ === 1) warn(`The \"next\" callback was called more than once in one navigation guard when going from \"${from.fullPath}\" to \"${to.fullPath}\". It should be called exactly one time in each navigation guard. This will fail in production.`);\n    // @ts-expect-error: we put it in the original one because it's easier to check\n    next._called = true;\n    if (called === 1) next.apply(null, arguments);\n  };\n}\nfunction extractComponentsGuards(matched, guardType, to, from) {\n  const guards = [];\n  for (const record of matched) {\n    for (const name in record.components) {\n      let rawComponent = record.components[name];\n      if (process.env.NODE_ENV !== 'production') {\n        if (!rawComponent || typeof rawComponent !== 'object' && typeof rawComponent !== 'function') {\n          warn(`Component \"${name}\" in record with path \"${record.path}\" is not` + ` a valid component. Received \"${String(rawComponent)}\".`);\n          // throw to ensure we stop here but warn to ensure the message isn't\n          // missed by the user\n          throw new Error('Invalid route component');\n        } else if ('then' in rawComponent) {\n          // warn if user wrote import('/component.vue') instead of () =>\n          // import('./component.vue')\n          warn(`Component \"${name}\" in record with path \"${record.path}\" is a ` + `Promise instead of a function that returns a Promise. Did you ` + `write \"import('./MyPage.vue')\" instead of ` + `\"() => import('./MyPage.vue')\" ? This will break in ` + `production if not fixed.`);\n          const promise = rawComponent;\n          rawComponent = () => promise;\n        } else if (rawComponent.__asyncLoader &&\n        // warn only once per component\n        !rawComponent.__warnedDefineAsync) {\n          rawComponent.__warnedDefineAsync = true;\n          warn(`Component \"${name}\" in record with path \"${record.path}\" is defined ` + `using \"defineAsyncComponent()\". ` + `Write \"() => import('./MyPage.vue')\" instead of ` + `\"defineAsyncComponent(() => import('./MyPage.vue'))\".`);\n        }\n      }\n      // skip update and leave guards if the route component is not mounted\n      if (guardType !== 'beforeRouteEnter' && !record.instances[name]) continue;\n      if (isRouteComponent(rawComponent)) {\n        // __vccOpts is added by vue-class-component and contain the regular options\n        const options = rawComponent.__vccOpts || rawComponent;\n        const guard = options[guardType];\n        guard && guards.push(guardToPromiseFn(guard, to, from, record, name));\n      } else {\n        // start requesting the chunk already\n        let componentPromise = rawComponent();\n        if (process.env.NODE_ENV !== 'production' && !('catch' in componentPromise)) {\n          warn(`Component \"${name}\" in record with path \"${record.path}\" is a function that does not return a Promise. If you were passing a functional component, make sure to add a \"displayName\" to the component. This will break in production if not fixed.`);\n          componentPromise = Promise.resolve(componentPromise);\n        }\n        guards.push(() => componentPromise.then(resolved => {\n          if (!resolved) return Promise.reject(new Error(`Couldn't resolve component \"${name}\" at \"${record.path}\"`));\n          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;\n          // replace the function with the resolved component\n          record.components[name] = resolvedComponent;\n          // __vccOpts is added by vue-class-component and contain the regular options\n          const options = resolvedComponent.__vccOpts || resolvedComponent;\n          const guard = options[guardType];\n          return guard && guardToPromiseFn(guard, to, from, record, name)();\n        }));\n      }\n    }\n  }\n  return guards;\n}\n/**\r\n * Allows differentiating lazy components from functional components and vue-class-component\r\n *\r\n * @param component\r\n */\nfunction isRouteComponent(component) {\n  return typeof component === 'object' || 'displayName' in component || 'props' in component || '__vccOpts' in component;\n}\n\n// TODO: we could allow currentRoute as a prop to expose `isActive` and\n// `isExactActive` behavior should go through an RFC\nfunction useLink(props) {\n  const router = inject(routerKey);\n  const currentRoute = inject(routeLocationKey);\n  const route = computed(() => router.resolve(unref(props.to)));\n  const activeRecordIndex = computed(() => {\n    const {\n      matched\n    } = route.value;\n    const {\n      length\n    } = matched;\n    const routeMatched = matched[length - 1];\n    const currentMatched = currentRoute.matched;\n    if (!routeMatched || !currentMatched.length) return -1;\n    const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));\n    if (index > -1) return index;\n    // possible parent record\n    const parentRecordPath = getOriginalPath(matched[length - 2]);\n    return (\n      // we are dealing with nested routes\n      length > 1 &&\n      // if the parent and matched route have the same path, this link is\n      // referring to the empty child. Or we currently are on a different\n      // child of the same parent\n      getOriginalPath(routeMatched) === parentRecordPath &&\n      // avoid comparing the child with its parent\n      currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index\n    );\n  });\n  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));\n  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));\n  function navigate(e = {}) {\n    if (guardEvent(e)) {\n      return router[unref(props.replace) ? 'replace' : 'push'](unref(props.to)\n      // avoid uncaught errors are they are logged anyway\n      ).catch(noop);\n    }\n    return Promise.resolve();\n  }\n  // devtools only\n  if ((process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) && isBrowser) {\n    const instance = getCurrentInstance();\n    if (instance) {\n      const linkContextDevtools = {\n        route: route.value,\n        isActive: isActive.value,\n        isExactActive: isExactActive.value\n      };\n      // @ts-expect-error: this is internal\n      instance.__vrl_devtools = instance.__vrl_devtools || [];\n      // @ts-expect-error: this is internal\n      instance.__vrl_devtools.push(linkContextDevtools);\n      watchEffect(() => {\n        linkContextDevtools.route = route.value;\n        linkContextDevtools.isActive = isActive.value;\n        linkContextDevtools.isExactActive = isExactActive.value;\n      }, {\n        flush: 'post'\n      });\n    }\n  }\n  return {\n    route,\n    href: computed(() => route.value.href),\n    isActive,\n    isExactActive,\n    navigate\n  };\n}\nconst RouterLinkImpl = /*#__PURE__*/defineComponent({\n  name: 'RouterLink',\n  props: {\n    to: {\n      type: [String, Object],\n      required: true\n    },\n    replace: Boolean,\n    activeClass: String,\n    // inactiveClass: String,\n    exactActiveClass: String,\n    custom: Boolean,\n    ariaCurrentValue: {\n      type: String,\n      default: 'page'\n    }\n  },\n  useLink,\n  setup(props, {\n    slots\n  }) {\n    const link = reactive(useLink(props));\n    const {\n      options\n    } = inject(routerKey);\n    const elClass = computed(() => ({\n      [getLinkClass(props.activeClass, options.linkActiveClass, 'router-link-active')]: link.isActive,\n      // [getLinkClass(\n      //   props.inactiveClass,\n      //   options.linkInactiveClass,\n      //   'router-link-inactive'\n      // )]: !link.isExactActive,\n      [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, 'router-link-exact-active')]: link.isExactActive\n    }));\n    return () => {\n      const children = slots.default && slots.default(link);\n      return props.custom ? children : h('a', {\n        'aria-current': link.isExactActive ? props.ariaCurrentValue : null,\n        href: link.href,\n        // this would override user added attrs but Vue will still add\n        // the listener so we end up triggering both\n        onClick: link.navigate,\n        class: elClass.value\n      }, children);\n    };\n  }\n});\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\n/**\r\n * Component to render a link that triggers a navigation on click.\r\n */\nconst RouterLink = RouterLinkImpl;\nfunction guardEvent(e) {\n  // don't redirect with control keys\n  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return;\n  // don't redirect when preventDefault called\n  if (e.defaultPrevented) return;\n  // don't redirect on right click\n  if (e.button !== undefined && e.button !== 0) return;\n  // don't redirect if `target=\"_blank\"`\n  // @ts-expect-error getAttribute does exist\n  if (e.currentTarget && e.currentTarget.getAttribute) {\n    // @ts-expect-error getAttribute exists\n    const target = e.currentTarget.getAttribute('target');\n    if (/\\b_blank\\b/i.test(target)) return;\n  }\n  // this may be a Weex event which doesn't have this method\n  if (e.preventDefault) e.preventDefault();\n  return true;\n}\nfunction includesParams(outer, inner) {\n  for (const key in inner) {\n    const innerValue = inner[key];\n    const outerValue = outer[key];\n    if (typeof innerValue === 'string') {\n      if (innerValue !== outerValue) return false;\n    } else {\n      if (!Array.isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i])) return false;\n    }\n  }\n  return true;\n}\n/**\r\n * Get the original path value of a record by following its aliasOf\r\n * @param record\r\n */\nfunction getOriginalPath(record) {\n  return record ? record.aliasOf ? record.aliasOf.path : record.path : '';\n}\n/**\r\n * Utility class to get the active class based on defaults.\r\n * @param propClass\r\n * @param globalClass\r\n * @param defaultClass\r\n */\nconst getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;\nconst RouterViewImpl = /*#__PURE__*/defineComponent({\n  name: 'RouterView',\n  // #674 we manually inherit them\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: String,\n      default: 'default'\n    },\n    route: Object\n  },\n  setup(props, {\n    attrs,\n    slots\n  }) {\n    process.env.NODE_ENV !== 'production' && warnDeprecatedUsage();\n    const injectedRoute = inject(routerViewLocationKey);\n    const routeToDisplay = computed(() => props.route || injectedRoute.value);\n    const depth = inject(viewDepthKey, 0);\n    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth]);\n    provide(viewDepthKey, depth + 1);\n    provide(matchedRouteKey, matchedRouteRef);\n    provide(routerViewLocationKey, routeToDisplay);\n    const viewRef = ref();\n    // watch at the same time the component instance, the route record we are\n    // rendering, and the name\n    watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {\n      // copy reused instances\n      if (to) {\n        // this will update the instance for new instances as well as reused\n        // instances when navigating to a new route\n        to.instances[name] = instance;\n        // the component instance is reused for a different route or name so\n        // we copy any saved update or leave guards. With async setup, the\n        // mounting component will mount before the matchedRoute changes,\n        // making instance === oldInstance, so we check if guards have been\n        // added before. This works because we remove guards when\n        // unmounting/deactivating components\n        if (from && from !== to && instance && instance === oldInstance) {\n          if (!to.leaveGuards.size) {\n            to.leaveGuards = from.leaveGuards;\n          }\n          if (!to.updateGuards.size) {\n            to.updateGuards = from.updateGuards;\n          }\n        }\n      }\n      // trigger beforeRouteEnter next callbacks\n      if (instance && to && (\n      // if there is no instance but to and from are the same this might be\n      // the first visit\n      !from || !isSameRouteRecord(to, from) || !oldInstance)) {\n        (to.enterCallbacks[name] || []).forEach(callback => callback(instance));\n      }\n    }, {\n      flush: 'post'\n    });\n    return () => {\n      const route = routeToDisplay.value;\n      const matchedRoute = matchedRouteRef.value;\n      const ViewComponent = matchedRoute && matchedRoute.components[props.name];\n      // we need the value at the time we render because when we unmount, we\n      // navigated to a different location so the value is different\n      const currentName = props.name;\n      if (!ViewComponent) {\n        return normalizeSlot(slots.default, {\n          Component: ViewComponent,\n          route\n        });\n      }\n      // props from route configuration\n      const routePropsOption = matchedRoute.props[props.name];\n      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === 'function' ? routePropsOption(route) : routePropsOption : null;\n      const onVnodeUnmounted = vnode => {\n        // remove the instance reference to prevent leak\n        if (vnode.component.isUnmounted) {\n          matchedRoute.instances[currentName] = null;\n        }\n      };\n      const component = h(ViewComponent, assign({}, routeProps, attrs, {\n        onVnodeUnmounted,\n        ref: viewRef\n      }));\n      if ((process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) && isBrowser && component.ref) {\n        // TODO: can display if it's an alias, its props\n        const info = {\n          depth,\n          name: matchedRoute.name,\n          path: matchedRoute.path,\n          meta: matchedRoute.meta\n        };\n        const internalInstances = Array.isArray(component.ref) ? component.ref.map(r => r.i) : [component.ref.i];\n        internalInstances.forEach(instance => {\n          // @ts-expect-error\n          instance.__vrv_devtools = info;\n        });\n      }\n      return (\n        // pass the vnode to the slot as a prop.\n        // h and <component :is=\"...\"> both accept vnodes\n        normalizeSlot(slots.default, {\n          Component: component,\n          route\n        }) || component\n      );\n    };\n  }\n});\nfunction normalizeSlot(slot, data) {\n  if (!slot) return null;\n  const slotContent = slot(data);\n  return slotContent.length === 1 ? slotContent[0] : slotContent;\n}\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\n/**\r\n * Component to display the current route the user is at.\r\n */\nconst RouterView = RouterViewImpl;\n// warn against deprecated usage with <transition> & <keep-alive>\n// due to functional component being no longer eager in Vue 3\nfunction warnDeprecatedUsage() {\n  const instance = getCurrentInstance();\n  const parentName = instance.parent && instance.parent.type.name;\n  if (parentName && (parentName === 'KeepAlive' || parentName.includes('Transition'))) {\n    const comp = parentName === 'KeepAlive' ? 'keep-alive' : 'transition';\n    warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\\n` + `Use slot props instead:\\n\\n` + `<router-view v-slot=\"{ Component }\">\\n` + `  <${comp}>\\n` + `    <component :is=\"Component\" />\\n` + `  </${comp}>\\n` + `</router-view>`);\n  }\n}\nfunction formatRouteLocation(routeLocation, tooltip) {\n  const copy = assign({}, routeLocation, {\n    // remove variables that can contain vue instances\n    matched: routeLocation.matched.map(matched => omit(matched, ['instances', 'children', 'aliasOf']))\n  });\n  return {\n    _custom: {\n      type: null,\n      readOnly: true,\n      display: routeLocation.fullPath,\n      tooltip,\n      value: copy\n    }\n  };\n}\nfunction formatDisplay(display) {\n  return {\n    _custom: {\n      display\n    }\n  };\n}\n// to support multiple router instances\nlet routerId = 0;\nfunction addDevtools(app, router, matcher) {\n  // Take over router.beforeEach and afterEach\n  // make sure we are not registering the devtool twice\n  if (router.__hasDevtools) return;\n  router.__hasDevtools = true;\n  // increment to support multiple router instances\n  const id = routerId++;\n  setupDevtoolsPlugin({\n    id: 'org.vuejs.router' + (id ? '.' + id : ''),\n    label: 'Vue Router',\n    packageName: 'vue-router',\n    homepage: 'https://router.vuejs.org',\n    logo: 'https://router.vuejs.org/logo.png',\n    componentStateTypes: ['Routing'],\n    app\n  }, api => {\n    // display state added by the router\n    api.on.inspectComponent((payload, ctx) => {\n      if (payload.instanceData) {\n        payload.instanceData.state.push({\n          type: 'Routing',\n          key: '$route',\n          editable: false,\n          value: formatRouteLocation(router.currentRoute.value, 'Current Route')\n        });\n      }\n    });\n    // mark router-link as active and display tags on router views\n    api.on.visitComponentTree(({\n      treeNode: node,\n      componentInstance\n    }) => {\n      if (componentInstance.__vrv_devtools) {\n        const info = componentInstance.__vrv_devtools;\n        node.tags.push({\n          label: (info.name ? `${info.name.toString()}: ` : '') + info.path,\n          textColor: 0,\n          tooltip: 'This component is rendered by &lt;router-view&gt;',\n          backgroundColor: PINK_500\n        });\n      }\n      // if multiple useLink are used\n      if (Array.isArray(componentInstance.__vrl_devtools)) {\n        componentInstance.__devtoolsApi = api;\n        componentInstance.__vrl_devtools.forEach(devtoolsData => {\n          let backgroundColor = ORANGE_400;\n          let tooltip = '';\n          if (devtoolsData.isExactActive) {\n            backgroundColor = LIME_500;\n            tooltip = 'This is exactly active';\n          } else if (devtoolsData.isActive) {\n            backgroundColor = BLUE_600;\n            tooltip = 'This link is active';\n          }\n          node.tags.push({\n            label: devtoolsData.route.path,\n            textColor: 0,\n            tooltip,\n            backgroundColor\n          });\n        });\n      }\n    });\n    watch(router.currentRoute, () => {\n      // refresh active state\n      refreshRoutesView();\n      api.notifyComponentUpdate();\n      api.sendInspectorTree(routerInspectorId);\n      api.sendInspectorState(routerInspectorId);\n    });\n    const navigationsLayerId = 'router:navigations:' + id;\n    api.addTimelineLayer({\n      id: navigationsLayerId,\n      label: `Router${id ? ' ' + id : ''} Navigations`,\n      color: 0x40a8c4\n    });\n    // const errorsLayerId = 'router:errors'\n    // api.addTimelineLayer({\n    //   id: errorsLayerId,\n    //   label: 'Router Errors',\n    //   color: 0xea5455,\n    // })\n    router.onError((error, to) => {\n      api.addTimelineEvent({\n        layerId: navigationsLayerId,\n        event: {\n          title: 'Error during Navigation',\n          subtitle: to.fullPath,\n          logType: 'error',\n          time: Date.now(),\n          data: {\n            error\n          },\n          groupId: to.meta.__navigationId\n        }\n      });\n    });\n    // attached to `meta` and used to group events\n    let navigationId = 0;\n    router.beforeEach((to, from) => {\n      const data = {\n        guard: formatDisplay('beforeEach'),\n        from: formatRouteLocation(from, 'Current Location during this navigation'),\n        to: formatRouteLocation(to, 'Target location')\n      };\n      // Used to group navigations together, hide from devtools\n      Object.defineProperty(to.meta, '__navigationId', {\n        value: navigationId++\n      });\n      api.addTimelineEvent({\n        layerId: navigationsLayerId,\n        event: {\n          time: Date.now(),\n          title: 'Start of navigation',\n          subtitle: to.fullPath,\n          data,\n          groupId: to.meta.__navigationId\n        }\n      });\n    });\n    router.afterEach((to, from, failure) => {\n      const data = {\n        guard: formatDisplay('afterEach')\n      };\n      if (failure) {\n        data.failure = {\n          _custom: {\n            type: Error,\n            readOnly: true,\n            display: failure ? failure.message : '',\n            tooltip: 'Navigation Failure',\n            value: failure\n          }\n        };\n        data.status = formatDisplay('❌');\n      } else {\n        data.status = formatDisplay('✅');\n      }\n      // we set here to have the right order\n      data.from = formatRouteLocation(from, 'Current Location during this navigation');\n      data.to = formatRouteLocation(to, 'Target location');\n      api.addTimelineEvent({\n        layerId: navigationsLayerId,\n        event: {\n          title: 'End of navigation',\n          subtitle: to.fullPath,\n          time: Date.now(),\n          data,\n          logType: failure ? 'warning' : 'default',\n          groupId: to.meta.__navigationId\n        }\n      });\n    });\n    /**\r\n     * Inspector of Existing routes\r\n     */\n    const routerInspectorId = 'router-inspector:' + id;\n    api.addInspector({\n      id: routerInspectorId,\n      label: 'Routes' + (id ? ' ' + id : ''),\n      icon: 'book',\n      treeFilterPlaceholder: 'Search routes'\n    });\n    function refreshRoutesView() {\n      // the routes view isn't active\n      if (!activeRoutesPayload) return;\n      const payload = activeRoutesPayload;\n      // children routes will appear as nested\n      let routes = matcher.getRoutes().filter(route => !route.parent);\n      // reset match state to false\n      routes.forEach(resetMatchStateOnRouteRecord);\n      // apply a match state if there is a payload\n      if (payload.filter) {\n        routes = routes.filter(route =>\n        // save matches state based on the payload\n        isRouteMatching(route, payload.filter.toLowerCase()));\n      }\n      // mark active routes\n      routes.forEach(route => markRouteRecordActive(route, router.currentRoute.value));\n      payload.rootNodes = routes.map(formatRouteRecordForInspector);\n    }\n    let activeRoutesPayload;\n    api.on.getInspectorTree(payload => {\n      activeRoutesPayload = payload;\n      if (payload.app === app && payload.inspectorId === routerInspectorId) {\n        refreshRoutesView();\n      }\n    });\n    /**\r\n     * Display information about the currently selected route record\r\n     */\n    api.on.getInspectorState(payload => {\n      if (payload.app === app && payload.inspectorId === routerInspectorId) {\n        const routes = matcher.getRoutes();\n        const route = routes.find(route => route.record.__vd_id === payload.nodeId);\n        if (route) {\n          payload.state = {\n            options: formatRouteRecordMatcherForStateInspector(route)\n          };\n        }\n      }\n    });\n    api.sendInspectorTree(routerInspectorId);\n    api.sendInspectorState(routerInspectorId);\n  });\n}\nfunction modifierForKey(key) {\n  if (key.optional) {\n    return key.repeatable ? '*' : '?';\n  } else {\n    return key.repeatable ? '+' : '';\n  }\n}\nfunction formatRouteRecordMatcherForStateInspector(route) {\n  const {\n    record\n  } = route;\n  const fields = [{\n    editable: false,\n    key: 'path',\n    value: record.path\n  }];\n  if (record.name != null) {\n    fields.push({\n      editable: false,\n      key: 'name',\n      value: record.name\n    });\n  }\n  fields.push({\n    editable: false,\n    key: 'regexp',\n    value: route.re\n  });\n  if (route.keys.length) {\n    fields.push({\n      editable: false,\n      key: 'keys',\n      value: {\n        _custom: {\n          type: null,\n          readOnly: true,\n          display: route.keys.map(key => `${key.name}${modifierForKey(key)}`).join(' '),\n          tooltip: 'Param keys',\n          value: route.keys\n        }\n      }\n    });\n  }\n  if (record.redirect != null) {\n    fields.push({\n      editable: false,\n      key: 'redirect',\n      value: record.redirect\n    });\n  }\n  if (route.alias.length) {\n    fields.push({\n      editable: false,\n      key: 'aliases',\n      value: route.alias.map(alias => alias.record.path)\n    });\n  }\n  fields.push({\n    key: 'score',\n    editable: false,\n    value: {\n      _custom: {\n        type: null,\n        readOnly: true,\n        display: route.score.map(score => score.join(', ')).join(' | '),\n        tooltip: 'Score used to sort routes',\n        value: route.score\n      }\n    }\n  });\n  return fields;\n}\n/**\r\n * Extracted from tailwind palette\r\n */\nconst PINK_500 = 0xec4899;\nconst BLUE_600 = 0x2563eb;\nconst LIME_500 = 0x84cc16;\nconst CYAN_400 = 0x22d3ee;\nconst ORANGE_400 = 0xfb923c;\n// const GRAY_100 = 0xf4f4f5\nconst DARK = 0x666666;\nfunction formatRouteRecordForInspector(route) {\n  const tags = [];\n  const {\n    record\n  } = route;\n  if (record.name != null) {\n    tags.push({\n      label: String(record.name),\n      textColor: 0,\n      backgroundColor: CYAN_400\n    });\n  }\n  if (record.aliasOf) {\n    tags.push({\n      label: 'alias',\n      textColor: 0,\n      backgroundColor: ORANGE_400\n    });\n  }\n  if (route.__vd_match) {\n    tags.push({\n      label: 'matches',\n      textColor: 0,\n      backgroundColor: PINK_500\n    });\n  }\n  if (route.__vd_exactActive) {\n    tags.push({\n      label: 'exact',\n      textColor: 0,\n      backgroundColor: LIME_500\n    });\n  }\n  if (route.__vd_active) {\n    tags.push({\n      label: 'active',\n      textColor: 0,\n      backgroundColor: BLUE_600\n    });\n  }\n  if (record.redirect) {\n    tags.push({\n      label: 'redirect: ' + (typeof record.redirect === 'string' ? record.redirect : 'Object'),\n      textColor: 0xffffff,\n      backgroundColor: DARK\n    });\n  }\n  // add an id to be able to select it. Using the `path` is not possible because\n  // empty path children would collide with their parents\n  let id = record.__vd_id;\n  if (id == null) {\n    id = String(routeRecordId++);\n    record.__vd_id = id;\n  }\n  return {\n    id,\n    label: record.path,\n    tags,\n    children: route.children.map(formatRouteRecordForInspector)\n  };\n}\n//  incremental id for route records and inspector state\nlet routeRecordId = 0;\nconst EXTRACT_REGEXP_RE = /^\\/(.*)\\/([a-z]*)$/;\nfunction markRouteRecordActive(route, currentRoute) {\n  // no route will be active if matched is empty\n  // reset the matching state\n  const isExactActive = currentRoute.matched.length && isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);\n  route.__vd_exactActive = route.__vd_active = isExactActive;\n  if (!isExactActive) {\n    route.__vd_active = currentRoute.matched.some(match => isSameRouteRecord(match, route.record));\n  }\n  route.children.forEach(childRoute => markRouteRecordActive(childRoute, currentRoute));\n}\nfunction resetMatchStateOnRouteRecord(route) {\n  route.__vd_match = false;\n  route.children.forEach(resetMatchStateOnRouteRecord);\n}\nfunction isRouteMatching(route, filter) {\n  const found = String(route.re).match(EXTRACT_REGEXP_RE);\n  route.__vd_match = false;\n  if (!found || found.length < 3) {\n    return false;\n  }\n  // use a regexp without $ at the end to match nested routes better\n  const nonEndingRE = new RegExp(found[1].replace(/\\$$/, ''), found[2]);\n  if (nonEndingRE.test(filter)) {\n    // mark children as matches\n    route.children.forEach(child => isRouteMatching(child, filter));\n    // exception case: `/`\n    if (route.record.path !== '/' || filter === '/') {\n      route.__vd_match = route.re.test(filter);\n      return true;\n    }\n    // hide the / route\n    return false;\n  }\n  const path = route.record.path.toLowerCase();\n  const decodedPath = decode(path);\n  // also allow partial matching on the path\n  if (!filter.startsWith('/') && (decodedPath.includes(filter) || path.includes(filter))) return true;\n  if (decodedPath.startsWith(filter) || path.startsWith(filter)) return true;\n  if (route.record.name && String(route.record.name).includes(filter)) return true;\n  return route.children.some(child => isRouteMatching(child, filter));\n}\nfunction omit(obj, keys) {\n  const ret = {};\n  for (const key in obj) {\n    if (!keys.includes(key)) {\n      // @ts-expect-error\n      ret[key] = obj[key];\n    }\n  }\n  return ret;\n}\n\n/**\r\n * Creates a Router instance that can be used by a Vue app.\r\n *\r\n * @param options - {@link RouterOptions}\r\n */\nfunction createRouter(options) {\n  const matcher = createRouterMatcher(options.routes, options);\n  const parseQuery$1 = options.parseQuery || parseQuery;\n  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;\n  const routerHistory = options.history;\n  if (process.env.NODE_ENV !== 'production' && !routerHistory) throw new Error('Provide the \"history\" option when calling \"createRouter()\":' + ' https://next.router.vuejs.org/api/#history.');\n  const beforeGuards = useCallbacks();\n  const beforeResolveGuards = useCallbacks();\n  const afterGuards = useCallbacks();\n  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);\n  let pendingLocation = START_LOCATION_NORMALIZED;\n  // leave the scrollRestoration if no scrollBehavior is provided\n  if (isBrowser && options.scrollBehavior && 'scrollRestoration' in history) {\n    history.scrollRestoration = 'manual';\n  }\n  const normalizeParams = applyToParams.bind(null, paramValue => '' + paramValue);\n  const encodeParams = applyToParams.bind(null, encodeParam);\n  const decodeParams =\n  // @ts-expect-error: intentionally avoid the type check\n  applyToParams.bind(null, decode);\n  function addRoute(parentOrRoute, route) {\n    let parent;\n    let record;\n    if (isRouteName(parentOrRoute)) {\n      parent = matcher.getRecordMatcher(parentOrRoute);\n      record = route;\n    } else {\n      record = parentOrRoute;\n    }\n    return matcher.addRoute(record, parent);\n  }\n  function removeRoute(name) {\n    const recordMatcher = matcher.getRecordMatcher(name);\n    if (recordMatcher) {\n      matcher.removeRoute(recordMatcher);\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn(`Cannot remove non-existent route \"${String(name)}\"`);\n    }\n  }\n  function getRoutes() {\n    return matcher.getRoutes().map(routeMatcher => routeMatcher.record);\n  }\n  function hasRoute(name) {\n    return !!matcher.getRecordMatcher(name);\n  }\n  function resolve(rawLocation, currentLocation) {\n    // const objectLocation = routerLocationAsObject(rawLocation)\n    // we create a copy to modify it later\n    currentLocation = assign({}, currentLocation || currentRoute.value);\n    if (typeof rawLocation === 'string') {\n      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);\n      const matchedRoute = matcher.resolve({\n        path: locationNormalized.path\n      }, currentLocation);\n      const href = routerHistory.createHref(locationNormalized.fullPath);\n      if (process.env.NODE_ENV !== 'production') {\n        if (href.startsWith('//')) warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);else if (!matchedRoute.matched.length) {\n          warn(`No match found for location with path \"${rawLocation}\"`);\n        }\n      }\n      // locationNormalized is always a new object\n      return assign(locationNormalized, matchedRoute, {\n        params: decodeParams(matchedRoute.params),\n        hash: decode(locationNormalized.hash),\n        redirectedFrom: undefined,\n        href\n      });\n    }\n    let matcherLocation;\n    // path could be relative in object as well\n    if ('path' in rawLocation) {\n      if (process.env.NODE_ENV !== 'production' && 'params' in rawLocation && !('name' in rawLocation) &&\n      // @ts-expect-error: the type is never\n      Object.keys(rawLocation.params).length) {\n        warn(`Path \"${\n        // @ts-expect-error: the type is never\n        rawLocation.path}\" was passed with params but they will be ignored. Use a named route alongside params instead.`);\n      }\n      matcherLocation = assign({}, rawLocation, {\n        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path\n      });\n    } else {\n      // remove any nullish param\n      const targetParams = assign({}, rawLocation.params);\n      for (const key in targetParams) {\n        if (targetParams[key] == null) {\n          delete targetParams[key];\n        }\n      }\n      // pass encoded values to the matcher so it can produce encoded path and fullPath\n      matcherLocation = assign({}, rawLocation, {\n        params: encodeParams(rawLocation.params)\n      });\n      // current location params are decoded, we need to encode them in case the\n      // matcher merges the params\n      currentLocation.params = encodeParams(currentLocation.params);\n    }\n    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);\n    const hash = rawLocation.hash || '';\n    if (process.env.NODE_ENV !== 'production' && hash && !hash.startsWith('#')) {\n      warn(`A \\`hash\\` should always start with the character \"#\". Replace \"${hash}\" with \"#${hash}\".`);\n    }\n    // decoding them) the matcher might have merged current location params so\n    // we need to run the decoding again\n    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));\n    const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {\n      hash: encodeHash(hash),\n      path: matchedRoute.path\n    }));\n    const href = routerHistory.createHref(fullPath);\n    if (process.env.NODE_ENV !== 'production') {\n      if (href.startsWith('//')) {\n        warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\n      } else if (!matchedRoute.matched.length) {\n        warn(`No match found for location with path \"${'path' in rawLocation ? rawLocation.path : rawLocation}\"`);\n      }\n    }\n    return assign({\n      fullPath,\n      // keep the hash encoded so fullPath is effectively path + encodedQuery +\n      // hash\n      hash,\n      query:\n      // if the user is using a custom query lib like qs, we might have\n      // nested objects, so we keep the query as is, meaning it can contain\n      // numbers at `$route.query`, but at the point, the user will have to\n      // use their own type anyway.\n      // https://github.com/vuejs/router/issues/328#issuecomment-649481567\n      stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}\n    }, matchedRoute, {\n      redirectedFrom: undefined,\n      href\n    });\n  }\n  function locationAsObject(to) {\n    return typeof to === 'string' ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);\n  }\n  function checkCanceledNavigation(to, from) {\n    if (pendingLocation !== to) {\n      return createRouterError(8 /* NAVIGATION_CANCELLED */, {\n        from,\n        to\n      });\n    }\n  }\n  function push(to) {\n    return pushWithRedirect(to);\n  }\n  function replace(to) {\n    return push(assign(locationAsObject(to), {\n      replace: true\n    }));\n  }\n  function handleRedirectRecord(to) {\n    const lastMatched = to.matched[to.matched.length - 1];\n    if (lastMatched && lastMatched.redirect) {\n      const {\n        redirect\n      } = lastMatched;\n      let newTargetLocation = typeof redirect === 'function' ? redirect(to) : redirect;\n      if (typeof newTargetLocation === 'string') {\n        newTargetLocation = newTargetLocation.includes('?') || newTargetLocation.includes('#') ? newTargetLocation = locationAsObject(newTargetLocation) :\n        // force empty params\n        {\n          path: newTargetLocation\n        };\n        // @ts-expect-error: force empty params when a string is passed to let\n        // the router parse them again\n        newTargetLocation.params = {};\n      }\n      if (process.env.NODE_ENV !== 'production' && !('path' in newTargetLocation) && !('name' in newTargetLocation)) {\n        warn(`Invalid redirect found:\\n${JSON.stringify(newTargetLocation, null, 2)}\\n when navigating to \"${to.fullPath}\". A redirect must contain a name or path. This will break in production.`);\n        throw new Error('Invalid redirect');\n      }\n      return assign({\n        query: to.query,\n        hash: to.hash,\n        params: to.params\n      }, newTargetLocation);\n    }\n  }\n  function pushWithRedirect(to, redirectedFrom) {\n    const targetLocation = pendingLocation = resolve(to);\n    const from = currentRoute.value;\n    const data = to.state;\n    const force = to.force;\n    // to could be a string where `replace` is a function\n    const replace = to.replace === true;\n    const shouldRedirect = handleRedirectRecord(targetLocation);\n    if (shouldRedirect) return pushWithRedirect(assign(locationAsObject(shouldRedirect), {\n      state: data,\n      force,\n      replace\n    }),\n    // keep original redirectedFrom if it exists\n    redirectedFrom || targetLocation);\n    // if it was a redirect we already called `pushWithRedirect` above\n    const toLocation = targetLocation;\n    toLocation.redirectedFrom = redirectedFrom;\n    let failure;\n    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {\n      failure = createRouterError(16 /* NAVIGATION_DUPLICATED */, {\n        to: toLocation,\n        from\n      });\n      // trigger scroll to allow scrolling to the same anchor\n      handleScroll(from, from,\n      // this is a push, the only way for it to be triggered from a\n      // history.listen is with a redirect, which makes it become a push\n      true,\n      // This cannot be the first navigation because the initial location\n      // cannot be manually navigated to\n      false);\n    }\n    return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch(error => isNavigationFailure(error) ?\n    // navigation redirects still mark the router as ready\n    isNavigationFailure(error, 2 /* NAVIGATION_GUARD_REDIRECT */) ? error : markAsReady(error) // also returns the error\n    :\n    // reject any unknown error\n    triggerError(error, toLocation, from)).then(failure => {\n      if (failure) {\n        if (isNavigationFailure(failure, 2 /* NAVIGATION_GUARD_REDIRECT */)) {\n          if (process.env.NODE_ENV !== 'production' &&\n          // we are redirecting to the same location we were already at\n          isSameRouteLocation(stringifyQuery$1, resolve(failure.to), toLocation) &&\n          // and we have done it a couple of times\n          redirectedFrom &&\n          // @ts-expect-error: added only in dev\n          (redirectedFrom._count = redirectedFrom._count ?\n          // @ts-expect-error\n          redirectedFrom._count + 1 : 1) > 10) {\n            warn(`Detected an infinite redirection in a navigation guard when going from \"${from.fullPath}\" to \"${toLocation.fullPath}\". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`);\n            return Promise.reject(new Error('Infinite redirect in navigation guard'));\n          }\n          return pushWithRedirect(\n          // keep options\n          assign(locationAsObject(failure.to), {\n            state: data,\n            force,\n            replace\n          }),\n          // preserve the original redirectedFrom if any\n          redirectedFrom || toLocation);\n        }\n      } else {\n        // if we fail we don't finalize the navigation\n        failure = finalizeNavigation(toLocation, from, true, replace, data);\n      }\n      triggerAfterEach(toLocation, from, failure);\n      return failure;\n    });\n  }\n  /**\r\n   * Helper to reject and skip all navigation guards if a new navigation happened\r\n   * @param to\r\n   * @param from\r\n   */\n  function checkCanceledNavigationAndReject(to, from) {\n    const error = checkCanceledNavigation(to, from);\n    return error ? Promise.reject(error) : Promise.resolve();\n  }\n  // TODO: refactor the whole before guards by internally using router.beforeEach\n  function navigate(to, from) {\n    let guards;\n    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);\n    // all components here have been resolved once because we are leaving\n    guards = extractComponentsGuards(leavingRecords.reverse(), 'beforeRouteLeave', to, from);\n    // leavingRecords is already reversed\n    for (const record of leavingRecords) {\n      record.leaveGuards.forEach(guard => {\n        guards.push(guardToPromiseFn(guard, to, from));\n      });\n    }\n    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);\n    guards.push(canceledNavigationCheck);\n    // run the queue of per route beforeRouteLeave guards\n    return runGuardQueue(guards).then(() => {\n      // check global guards beforeEach\n      guards = [];\n      for (const guard of beforeGuards.list()) {\n        guards.push(guardToPromiseFn(guard, to, from));\n      }\n      guards.push(canceledNavigationCheck);\n      return runGuardQueue(guards);\n    }).then(() => {\n      // check in components beforeRouteUpdate\n      guards = extractComponentsGuards(updatingRecords, 'beforeRouteUpdate', to, from);\n      for (const record of updatingRecords) {\n        record.updateGuards.forEach(guard => {\n          guards.push(guardToPromiseFn(guard, to, from));\n        });\n      }\n      guards.push(canceledNavigationCheck);\n      // run the queue of per route beforeEnter guards\n      return runGuardQueue(guards);\n    }).then(() => {\n      // check the route beforeEnter\n      guards = [];\n      for (const record of to.matched) {\n        // do not trigger beforeEnter on reused views\n        if (record.beforeEnter && !from.matched.includes(record)) {\n          if (Array.isArray(record.beforeEnter)) {\n            for (const beforeEnter of record.beforeEnter) guards.push(guardToPromiseFn(beforeEnter, to, from));\n          } else {\n            guards.push(guardToPromiseFn(record.beforeEnter, to, from));\n          }\n        }\n      }\n      guards.push(canceledNavigationCheck);\n      // run the queue of per route beforeEnter guards\n      return runGuardQueue(guards);\n    }).then(() => {\n      // NOTE: at this point to.matched is normalized and does not contain any () => Promise<Component>\n      // clear existing enterCallbacks, these are added by extractComponentsGuards\n      to.matched.forEach(record => record.enterCallbacks = {});\n      // check in-component beforeRouteEnter\n      guards = extractComponentsGuards(enteringRecords, 'beforeRouteEnter', to, from);\n      guards.push(canceledNavigationCheck);\n      // run the queue of per route beforeEnter guards\n      return runGuardQueue(guards);\n    }).then(() => {\n      // check global guards beforeResolve\n      guards = [];\n      for (const guard of beforeResolveGuards.list()) {\n        guards.push(guardToPromiseFn(guard, to, from));\n      }\n      guards.push(canceledNavigationCheck);\n      return runGuardQueue(guards);\n    })\n    // catch any navigation canceled\n    .catch(err => isNavigationFailure(err, 8 /* NAVIGATION_CANCELLED */) ? err : Promise.reject(err));\n  }\n  function triggerAfterEach(to, from, failure) {\n    // navigation is confirmed, call afterGuards\n    // TODO: wrap with error handlers\n    for (const guard of afterGuards.list()) guard(to, from, failure);\n  }\n  /**\r\n   * - Cleans up any navigation guards\r\n   * - Changes the url if necessary\r\n   * - Calls the scrollBehavior\r\n   */\n  function finalizeNavigation(toLocation, from, isPush, replace, data) {\n    // a more recent navigation took place\n    const error = checkCanceledNavigation(toLocation, from);\n    if (error) return error;\n    // only consider as push if it's not the first navigation\n    const isFirstNavigation = from === START_LOCATION_NORMALIZED;\n    const state = !isBrowser ? {} : history.state;\n    // change URL only if the user did a push/replace and if it's not the initial navigation because\n    // it's just reflecting the url\n    if (isPush) {\n      // on the initial navigation, we want to reuse the scroll position from\n      // history state if it exists\n      if (replace || isFirstNavigation) routerHistory.replace(toLocation.fullPath, assign({\n        scroll: isFirstNavigation && state && state.scroll\n      }, data));else routerHistory.push(toLocation.fullPath, data);\n    }\n    // accept current navigation\n    currentRoute.value = toLocation;\n    handleScroll(toLocation, from, isPush, isFirstNavigation);\n    markAsReady();\n  }\n  let removeHistoryListener;\n  // attach listener to history to trigger navigations\n  function setupListeners() {\n    removeHistoryListener = routerHistory.listen((to, _from, info) => {\n      // cannot be a redirect route because it was in history\n      const toLocation = resolve(to);\n      // due to dynamic routing, and to hash history with manual navigation\n      // (manually changing the url or calling history.hash = '#/somewhere'),\n      // there could be a redirect record in history\n      const shouldRedirect = handleRedirectRecord(toLocation);\n      if (shouldRedirect) {\n        pushWithRedirect(assign(shouldRedirect, {\n          replace: true\n        }), toLocation).catch(noop);\n        return;\n      }\n      pendingLocation = toLocation;\n      const from = currentRoute.value;\n      // TODO: should be moved to web history?\n      if (isBrowser) {\n        saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());\n      }\n      navigate(toLocation, from).catch(error => {\n        if (isNavigationFailure(error, 4 /* NAVIGATION_ABORTED */ | 8 /* NAVIGATION_CANCELLED */)) {\n          return error;\n        }\n        if (isNavigationFailure(error, 2 /* NAVIGATION_GUARD_REDIRECT */)) {\n          // Here we could call if (info.delta) routerHistory.go(-info.delta,\n          // false) but this is bug prone as we have no way to wait the\n          // navigation to be finished before calling pushWithRedirect. Using\n          // a setTimeout of 16ms seems to work but there is not guarantee for\n          // it to work on every browser. So Instead we do not restore the\n          // history entry and trigger a new navigation as requested by the\n          // navigation guard.\n          // the error is already handled by router.push we just want to avoid\n          // logging the error\n          pushWithRedirect(error.to, toLocation\n          // avoid an uncaught rejection, let push call triggerError\n          ).then(failure => {\n            // manual change in hash history #916 ending up in the URL not\n            // changing but it was changed by the manual url change, so we\n            // need to manually change it ourselves\n            if (isNavigationFailure(failure, 4 /* NAVIGATION_ABORTED */ | 16 /* NAVIGATION_DUPLICATED */) && !info.delta && info.type === NavigationType.pop) {\n              routerHistory.go(-1, false);\n            }\n          }).catch(noop);\n          // avoid the then branch\n          return Promise.reject();\n        }\n        // do not restore history on unknown direction\n        if (info.delta) routerHistory.go(-info.delta, false);\n        // unrecognized error, transfer to the global handler\n        return triggerError(error, toLocation, from);\n      }).then(failure => {\n        failure = failure || finalizeNavigation(\n        // after navigation, all matched components are resolved\n        toLocation, from, false);\n        // revert the navigation\n        if (failure) {\n          if (info.delta) {\n            routerHistory.go(-info.delta, false);\n          } else if (info.type === NavigationType.pop && isNavigationFailure(failure, 4 /* NAVIGATION_ABORTED */ | 16 /* NAVIGATION_DUPLICATED */)) {\n            // manual change in hash history #916\n            // it's like a push but lacks the information of the direction\n            routerHistory.go(-1, false);\n          }\n        }\n        triggerAfterEach(toLocation, from, failure);\n      }).catch(noop);\n    });\n  }\n  // Initialization and Errors\n  let readyHandlers = useCallbacks();\n  let errorHandlers = useCallbacks();\n  let ready;\n  /**\r\n   * Trigger errorHandlers added via onError and throws the error as well\r\n   *\r\n   * @param error - error to throw\r\n   * @param to - location we were navigating to when the error happened\r\n   * @param from - location we were navigating from when the error happened\r\n   * @returns the error as a rejected promise\r\n   */\n  function triggerError(error, to, from) {\n    markAsReady(error);\n    const list = errorHandlers.list();\n    if (list.length) {\n      list.forEach(handler => handler(error, to, from));\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        warn('uncaught error during route navigation:');\n      }\n      console.error(error);\n    }\n    return Promise.reject(error);\n  }\n  function isReady() {\n    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED) return Promise.resolve();\n    return new Promise((resolve, reject) => {\n      readyHandlers.add([resolve, reject]);\n    });\n  }\n  function markAsReady(err) {\n    if (!ready) {\n      // still not ready if an error happened\n      ready = !err;\n      setupListeners();\n      readyHandlers.list().forEach(([resolve, reject]) => err ? reject(err) : resolve());\n      readyHandlers.reset();\n    }\n    return err;\n  }\n  // Scroll behavior\n  function handleScroll(to, from, isPush, isFirstNavigation) {\n    const {\n      scrollBehavior\n    } = options;\n    if (!isBrowser || !scrollBehavior) return Promise.resolve();\n    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;\n    return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then(position => position && scrollToPosition(position)).catch(err => triggerError(err, to, from));\n  }\n  const go = delta => routerHistory.go(delta);\n  let started;\n  const installedApps = new Set();\n  const router = {\n    currentRoute,\n    addRoute,\n    removeRoute,\n    hasRoute,\n    getRoutes,\n    resolve,\n    options,\n    push,\n    replace,\n    go,\n    back: () => go(-1),\n    forward: () => go(1),\n    beforeEach: beforeGuards.add,\n    beforeResolve: beforeResolveGuards.add,\n    afterEach: afterGuards.add,\n    onError: errorHandlers.add,\n    isReady,\n    install(app) {\n      const router = this;\n      app.component('RouterLink', RouterLink);\n      app.component('RouterView', RouterView);\n      app.config.globalProperties.$router = router;\n      Object.defineProperty(app.config.globalProperties, '$route', {\n        enumerable: true,\n        get: () => unref(currentRoute)\n      });\n      // this initial navigation is only necessary on client, on server it doesn't\n      // make sense because it will create an extra unnecessary navigation and could\n      // lead to problems\n      if (isBrowser &&\n      // used for the initial navigation client side to avoid pushing\n      // multiple times when the router is used in multiple apps\n      !started && currentRoute.value === START_LOCATION_NORMALIZED) {\n        // see above\n        started = true;\n        push(routerHistory.location).catch(err => {\n          if (process.env.NODE_ENV !== 'production') warn('Unexpected error when starting the router:', err);\n        });\n      }\n      const reactiveRoute = {};\n      for (const key in START_LOCATION_NORMALIZED) {\n        // @ts-expect-error: the key matches\n        reactiveRoute[key] = computed(() => currentRoute.value[key]);\n      }\n      app.provide(routerKey, router);\n      app.provide(routeLocationKey, reactive(reactiveRoute));\n      app.provide(routerViewLocationKey, currentRoute);\n      const unmountApp = app.unmount;\n      installedApps.add(app);\n      app.unmount = function () {\n        installedApps.delete(app);\n        // the router is not attached to an app anymore\n        if (installedApps.size < 1) {\n          // invalidate the current navigation\n          pendingLocation = START_LOCATION_NORMALIZED;\n          removeHistoryListener && removeHistoryListener();\n          currentRoute.value = START_LOCATION_NORMALIZED;\n          started = false;\n          ready = false;\n        }\n        unmountApp();\n      };\n      if ((process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) && isBrowser) {\n        addDevtools(app, router, matcher);\n      }\n    }\n  };\n  return router;\n}\nfunction runGuardQueue(guards) {\n  return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());\n}\nfunction extractChangingRecords(to, from) {\n  const leavingRecords = [];\n  const updatingRecords = [];\n  const enteringRecords = [];\n  const len = Math.max(from.matched.length, to.matched.length);\n  for (let i = 0; i < len; i++) {\n    const recordFrom = from.matched[i];\n    if (recordFrom) {\n      if (to.matched.find(record => isSameRouteRecord(record, recordFrom))) updatingRecords.push(recordFrom);else leavingRecords.push(recordFrom);\n    }\n    const recordTo = to.matched[i];\n    if (recordTo) {\n      // the type doesn't matter because we are comparing per reference\n      if (!from.matched.find(record => isSameRouteRecord(record, recordTo))) {\n        enteringRecords.push(recordTo);\n      }\n    }\n  }\n  return [leavingRecords, updatingRecords, enteringRecords];\n}\n\n/**\r\n * Returns the router instance. Equivalent to using `$router` inside\r\n * templates.\r\n */\nfunction useRouter() {\n  return inject(routerKey);\n}\n/**\r\n * Returns the current route location. Equivalent to using `$route` inside\r\n * templates.\r\n */\nfunction useRoute() {\n  return inject(routeLocationKey);\n}\nexport { NavigationFailureType, RouterLink, RouterView, START_LOCATION_NORMALIZED as START_LOCATION, createMemoryHistory, createRouter, createRouterMatcher, createWebHashHistory, createWebHistory, isNavigationFailure, matchedRouteKey, onBeforeRouteLeave, onBeforeRouteUpdate, parseQuery, routeLocationKey, routerKey, routerViewLocationKey, stringifyQuery, useLink, useRoute, useRouter, viewDepthKey };"],
  "mappings": "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",
  "names": ["parseQuery", "location", "stringifyQuery", "NavigationType", "NavigationDirection", "history", "replace", "NavigationFailureType", "re", "value", "route", "matchedRoute", "href", "failure", "resolve", "router"]
}
